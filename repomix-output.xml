This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
app/api/enhance/route.ts
app/api/extract/route.ts
app/api/generate-image/route.ts
app/globals.css
app/layout.tsx
app/page.tsx
components/CopyButton.tsx
components/infographic/AssumptionsList.tsx
components/infographic/ChapterSummaries.tsx
components/infographic/ExecutiveNarrative.tsx
components/infographic/HeaderBanner.tsx
components/infographic/HighlightCards.tsx
components/infographic/index.ts
components/infographic/InfographicContainer.tsx
components/infographic/InfographicHeader.tsx
components/infographic/NextStepsTimeline.tsx
components/infographic/SixTRadar.tsx
components/infographic/VerdictCard.tsx
components/infographic/VerdictPair.tsx
components/JsonOutput.tsx
components/MemoInput.tsx
lib/infographic-styles.ts
lib/openrouter.ts
lib/prompts.ts
lib/schema.ts
next.config.mjs
package.json
postcss.config.mjs
README.md
tailwind.config.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/api/enhance/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { ExtractionResult } from '@/lib/schema';

export const maxDuration = 60;

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
const MODEL = 'google/gemini-2.5-pro-preview';

interface EnhanceRequest {
  data: ExtractionResult;
}

interface EnhanceResponse {
  success: boolean;
  narrative?: string;
  error?: string;
}

export async function POST(request: NextRequest): Promise<NextResponse<EnhanceResponse>> {
  try {
    const body: EnhanceRequest = await request.json();

    if (!body.data) {
      return NextResponse.json(
        { success: false, error: 'Missing extraction data' },
        { status: 400 }
      );
    }

    const apiKey = process.env.OPENROUTER_API_KEY;

    if (!apiKey) {
      console.error('OPENROUTER_API_KEY is not configured');
      return NextResponse.json(
        { success: false, error: 'Server configuration error' },
        { status: 500 }
      );
    }

    const { data } = body;
    
    // Build a concise summary of the extraction for the prompt
    const summaryContext = `
Project: ${data.metadata.projectName}
Industry: ${data.metadata.industry}
Location: ${data.metadata.location || 'Not specified'}
Stage: ${data.metadata.stage}
Decision: ${data.metadata.decision}
Recommendation: ${data.metadata.recommendation}

Executive Summary: ${data.executiveSummary.verdict}

Key Reasoning:
${data.executiveSummary.coreReasoning.map(r => `- ${r}`).join('\n')}

Six-T Risks:
- Team: ${data.sixTRisks.team.rating} - ${data.sixTRisks.team.summary}
- TAM: ${data.sixTRisks.tam.rating} - ${data.sixTRisks.tam.summary}
- Technology: ${data.sixTRisks.technology.rating} - ${data.sixTRisks.technology.summary}
- Traction: ${data.sixTRisks.traction.rating} - ${data.sixTRisks.traction.summary}
- Terms: ${data.sixTRisks.terms.rating} - ${data.sixTRisks.terms.summary}
- Trends: ${data.sixTRisks.trends.rating} - ${data.sixTRisks.trends.summary}

Should We Do It: ${data.shouldWeDoIt.verdict} (${data.shouldWeDoIt.confidenceLevel} confidence)
Can We Do It: ${data.canWeDoIt.verdict} (${data.canWeDoIt.confidenceLevel} confidence)

Key Highlights:
${data.highlights.map(h => `- ${h.metric}: ${h.value}`).join('\n')}
`.trim();

    const systemPrompt = `You are an executive communications specialist at a venture capital firm. Your task is to synthesize investment analysis into a brief narrative summary that a CEO could read aloud at a board meeting.

Rules:
- Write exactly 3-4 sentences
- Use plain English, no jargon or bullet points
- Be direct and decisive
- Focus on the key recommendation and primary reasoning
- Include one specific data point or metric
- End with a clear directional statement

The tone should be confident and businesslike, as if briefing a senior executive.`;

    const userPrompt = `Based on this investment analysis, write a 3-4 sentence executive narrative summary:

${summaryContext}`;

    console.log('Generating executive narrative...');
    const startTime = Date.now();

    const response = await fetch(OPENROUTER_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`,
        'HTTP-Referer': 'https://olsenator.vercel.app',
        'X-Title': 'The Olsenator',
      },
      body: JSON.stringify({
        model: MODEL,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt },
        ],
        temperature: 0.7,
        max_tokens: 500,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('OpenRouter API error:', response.status, errorText);
      return NextResponse.json(
        { success: false, error: 'Failed to generate narrative' },
        { status: 500 }
      );
    }

    const result = await response.json();
    const duration = Date.now() - startTime;
    console.log(`Narrative generated in ${duration}ms`);

    if (!result.choices || result.choices.length === 0) {
      return NextResponse.json(
        { success: false, error: 'No narrative generated' },
        { status: 500 }
      );
    }

    const narrative = result.choices[0].message.content.trim();

    return NextResponse.json({
      success: true,
      narrative,
    });
  } catch (error) {
    console.error('Unexpected error in enhance route:', error);
    return NextResponse.json(
      { 
        success: false, 
        error: error instanceof Error ? error.message : 'An unexpected error occurred' 
      },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/generate-image/route.ts">
import { NextRequest, NextResponse } from 'next/server';

export const maxDuration = 120; // Image generation can take longer

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
const IMAGE_MODEL = 'google/gemini-2.5-flash-image';

interface GenerateImageRequest {
  projectName: string;
  industry: string;
  location?: string | null;
}

interface GenerateImageResponse {
  success: boolean;
  imageUrl?: string;
  error?: string;
}

export async function POST(request: NextRequest): Promise<NextResponse<GenerateImageResponse>> {
  try {
    const body: GenerateImageRequest = await request.json();

    if (!body.projectName || !body.industry) {
      return NextResponse.json(
        { success: false, error: 'Missing project name or industry' },
        { status: 400 }
      );
    }

    const apiKey = process.env.OPENROUTER_API_KEY;

    if (!apiKey) {
      console.error('OPENROUTER_API_KEY is not configured');
      return NextResponse.json(
        { success: false, error: 'Server configuration error' },
        { status: 500 }
      );
    }

    // Build the image generation prompt
    const locationContext = body.location ? ` in ${body.location}` : '';
    const prompt = `Professional minimal illustration of ${body.industry.toLowerCase()} industry${locationContext}, abstract geometric style, navy blue (#1e293b) and white color scheme, clean lines, modern corporate aesthetic, suitable for business presentation header, no text, no people`;

    console.log('Generating header image with prompt:', prompt);
    const startTime = Date.now();

    // Call OpenRouter with the image generation model
    const response = await fetch(OPENROUTER_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`,
        'HTTP-Referer': 'https://olsenator.vercel.app',
        'X-Title': 'The Olsenator',
      },
      body: JSON.stringify({
        model: IMAGE_MODEL,
        messages: [
          {
            role: 'user',
            content: prompt,
          },
        ],
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('OpenRouter API error:', response.status, errorText);
      
      // Return gracefully - image generation is optional
      return NextResponse.json(
        { success: false, error: 'Image generation unavailable' },
        { status: 200 } // Return 200 so frontend doesn't treat as error
      );
    }

    const result = await response.json();
    const duration = Date.now() - startTime;
    console.log(`Image generated in ${duration}ms`);

    // Extract image URL from response
    // OpenRouter returns images in different formats depending on the model
    let imageUrl: string | undefined;

    if (result.choices && result.choices[0]?.message?.content) {
      const content = result.choices[0].message.content;
      
      // Check if content is a URL
      if (typeof content === 'string' && content.startsWith('http')) {
        imageUrl = content;
      } else if (typeof content === 'string' && content.startsWith('data:image')) {
        // Base64 data URL
        imageUrl = content;
      } else if (Array.isArray(content)) {
        // Some models return content as array with image_url
        const imageContent = content.find((c: { type: string }) => c.type === 'image_url');
        if (imageContent?.image_url?.url) {
          imageUrl = imageContent.image_url.url;
        }
      }
    }

    // Also check for image in response data directly
    if (!imageUrl && result.data?.url) {
      imageUrl = result.data.url;
    }

    if (!imageUrl) {
      console.log('No image URL in response:', JSON.stringify(result, null, 2));
      return NextResponse.json(
        { success: false, error: 'No image generated' },
        { status: 200 }
      );
    }

    return NextResponse.json({
      success: true,
      imageUrl,
    });
  } catch (error) {
    console.error('Unexpected error in generate-image route:', error);
    // Return gracefully - image generation is optional
    return NextResponse.json(
      { 
        success: false, 
        error: error instanceof Error ? error.message : 'Image generation failed' 
      },
      { status: 200 }
    );
  }
}
</file>

<file path="components/infographic/AssumptionsList.tsx">
'use client';

import { CriticalAssumption } from '@/lib/schema';
import { colors, typography, getAssumptionColor, getAssumptionBgColor } from '@/lib/infographic-styles';

interface AssumptionsListProps {
  assumptions: CriticalAssumption[];
}

function getStatusIcon(status: string) {
  switch (status) {
    case 'validated':
      return (
        <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
          <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
        </svg>
      );
    case 'pending':
      return (
        <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
          <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clipRule="evenodd" />
        </svg>
      );
    case 'at-risk':
      return (
        <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
          <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
        </svg>
      );
    default:
      return null;
  }
}

function getStatusLabel(status: string): string {
  switch (status) {
    case 'validated':
      return 'Validated';
    case 'pending':
      return 'Pending';
    case 'at-risk':
      return 'At Risk';
    default:
      return status;
  }
}

export function AssumptionsList({ assumptions }: AssumptionsListProps) {
  if (assumptions.length === 0) return null;

  // Group by status for better organization
  const validated = assumptions.filter(a => a.status === 'validated');
  const pending = assumptions.filter(a => a.status === 'pending');
  const atRisk = assumptions.filter(a => a.status === 'at-risk');

  return (
    <div 
      className="avoid-break rounded-lg p-6"
      style={{ 
        backgroundColor: colors.white,
        border: `1px solid ${colors.slate[200]}`,
      }}
    >
      <div className="flex items-center gap-2 mb-4">
        <div 
          className="w-1 h-6 rounded-full"
          style={{ backgroundColor: colors.navy }}
        />
        <h2 
          className="text-lg font-semibold"
          style={{ 
            color: colors.navy,
            fontFamily: typography.fontFamily.sans,
            fontWeight: typography.fontWeight.semibold,
          }}
        >
          Critical Assumptions
        </h2>
      </div>

      <p 
        className="text-sm mb-4"
        style={{ color: colors.slate[500] }}
      >
        What you would have to believe for this investment to succeed
      </p>

      <div className="space-y-2">
        {/* At Risk First (most important) */}
        {atRisk.map((assumption, index) => (
          <AssumptionItem key={`at-risk-${index}`} assumption={assumption} />
        ))}
        
        {/* Pending */}
        {pending.map((assumption, index) => (
          <AssumptionItem key={`pending-${index}`} assumption={assumption} />
        ))}
        
        {/* Validated Last */}
        {validated.map((assumption, index) => (
          <AssumptionItem key={`validated-${index}`} assumption={assumption} />
        ))}
      </div>

      {/* Summary Stats */}
      <div 
        className="flex items-center gap-4 mt-4 pt-4"
        style={{ borderTop: `1px solid ${colors.slate[200]}` }}
      >
        <div className="flex items-center gap-2">
          <span 
            className="w-2 h-2 rounded-full"
            style={{ backgroundColor: colors.assumption.validated }}
          />
          <span className="text-xs" style={{ color: colors.slate[500] }}>
            {validated.length} Validated
          </span>
        </div>
        <div className="flex items-center gap-2">
          <span 
            className="w-2 h-2 rounded-full"
            style={{ backgroundColor: colors.assumption.pending }}
          />
          <span className="text-xs" style={{ color: colors.slate[500] }}>
            {pending.length} Pending
          </span>
        </div>
        <div className="flex items-center gap-2">
          <span 
            className="w-2 h-2 rounded-full"
            style={{ backgroundColor: colors.assumption.atRisk }}
          />
          <span className="text-xs" style={{ color: colors.slate[500] }}>
            {atRisk.length} At Risk
          </span>
        </div>
      </div>
    </div>
  );
}

function AssumptionItem({ assumption }: { assumption: CriticalAssumption }) {
  const statusColor = getAssumptionColor(assumption.status);
  const statusBgColor = getAssumptionBgColor(assumption.status);

  return (
    <div 
      className="flex items-start gap-3 p-3 rounded-lg"
      style={{ backgroundColor: statusBgColor }}
    >
      <div 
        className="flex-shrink-0 mt-0.5"
        style={{ color: statusColor }}
      >
        {getStatusIcon(assumption.status)}
      </div>
      <div className="flex-1 min-w-0">
        <span 
          className="text-sm leading-relaxed"
          style={{ 
            color: colors.slate[700],
            lineHeight: typography.lineHeight.relaxed,
          }}
        >
          {assumption.assumption}
        </span>
      </div>
      <span 
        className="flex-shrink-0 text-xs font-medium px-2 py-0.5 rounded"
        style={{ 
          color: statusColor,
          backgroundColor: colors.white,
        }}
      >
        {getStatusLabel(assumption.status)}
      </span>
    </div>
  );
}
</file>

<file path="components/infographic/ChapterSummaries.tsx">
'use client';

import { useState } from 'react';
import { Chapters } from '@/lib/schema';
import { colors, typography } from '@/lib/infographic-styles';

interface ChapterSummariesProps {
  chapters: Chapters;
}

type ChapterTab = 'team' | 'opportunity' | 'path' | 'operations';

export function ChapterSummaries({ chapters }: ChapterSummariesProps) {
  const [activeTab, setActiveTab] = useState<ChapterTab>('team');

  const tabs: { id: ChapterTab; label: string }[] = [
    { id: 'team', label: 'Team' },
    { id: 'opportunity', label: 'Opportunity' },
    { id: 'path', label: 'Path to Success' },
    { id: 'operations', label: 'Operations' },
  ];

  return (
    <div 
      className="page-break-before rounded-lg overflow-hidden"
      style={{ 
        backgroundColor: colors.white,
        border: `1px solid ${colors.slate[200]}`,
      }}
    >
      <div className="flex items-center gap-2 p-6 pb-4">
        <div 
          className="w-1 h-6 rounded-full"
          style={{ backgroundColor: colors.navy }}
        />
        <h2 
          className="text-lg font-semibold"
          style={{ 
            color: colors.navy,
            fontFamily: typography.fontFamily.sans,
            fontWeight: typography.fontWeight.semibold,
          }}
        >
          Detailed Analysis
        </h2>
      </div>

      {/* Tabs */}
      <div 
        className="flex border-b px-6 no-print"
        style={{ borderColor: colors.slate[200] }}
      >
        {tabs.map((tab) => (
          <button
            key={tab.id}
            onClick={() => setActiveTab(tab.id)}
            className="px-4 py-3 text-sm font-medium transition-colors relative"
            style={{ 
              color: activeTab === tab.id ? colors.navy : colors.slate[500],
            }}
          >
            {tab.label}
            {activeTab === tab.id && (
              <div 
                className="absolute bottom-0 left-0 right-0 h-0.5"
                style={{ backgroundColor: colors.navy }}
              />
            )}
          </button>
        ))}
      </div>

      {/* Tab Content - Screen View */}
      <div className="p-6 no-print">
        {activeTab === 'team' && <TeamChapter team={chapters.team} />}
        {activeTab === 'opportunity' && <OpportunityChapter opportunity={chapters.opportunityValidation} />}
        {activeTab === 'path' && <PathChapter path={chapters.pathToSuccess} />}
        {activeTab === 'operations' && <OperationsChapter operations={chapters.operations} />}
      </div>

      {/* Print View - Show All */}
      <div className="p-6 print-only hidden print:block">
        <div className="space-y-8">
          <div>
            <h3 
              className="text-sm font-semibold uppercase tracking-wider mb-4"
              style={{ color: colors.navy }}
            >
              Team Analysis
            </h3>
            <TeamChapter team={chapters.team} />
          </div>
          <div>
            <h3 
              className="text-sm font-semibold uppercase tracking-wider mb-4"
              style={{ color: colors.navy }}
            >
              Opportunity Validation
            </h3>
            <OpportunityChapter opportunity={chapters.opportunityValidation} />
          </div>
          <div>
            <h3 
              className="text-sm font-semibold uppercase tracking-wider mb-4"
              style={{ color: colors.navy }}
            >
              Path to Success
            </h3>
            <PathChapter path={chapters.pathToSuccess} />
          </div>
          <div>
            <h3 
              className="text-sm font-semibold uppercase tracking-wider mb-4"
              style={{ color: colors.navy }}
            >
              Operations
            </h3>
            <OperationsChapter operations={chapters.operations} />
          </div>
        </div>
      </div>
    </div>
  );
}

function TeamChapter({ team }: { team: Chapters['team'] }) {
  return (
    <div className="space-y-4">
      <Section title="Capability Assessment" content={team.capabilityAssessment} />
      {team.identifiedGaps.length > 0 && (
        <Section title="Identified Gaps" items={team.identifiedGaps} />
      )}
      {team.dataPoints.length > 0 && (
        <DataPoints items={team.dataPoints} />
      )}
    </div>
  );
}

function OpportunityChapter({ opportunity }: { opportunity: Chapters['opportunityValidation'] }) {
  return (
    <div className="space-y-4">
      <Section title="Problem Statement" content={opportunity.problemStatement} />
      <Section title="Market Size" content={opportunity.marketSize} />
      <Section title="Competitive Positioning" content={opportunity.competitivePositioning} />
      {opportunity.dataPoints.length > 0 && (
        <DataPoints items={opportunity.dataPoints} />
      )}
    </div>
  );
}

function PathChapter({ path }: { path: Chapters['pathToSuccess'] }) {
  return (
    <div className="space-y-4">
      <Section title="Product Requirements" content={path.productRequirements} />
      <Section title="Go-to-Market" content={path.goToMarket} />
      <Section title="Revenue Model" content={path.revenueModel} />
      {path.dataPoints.length > 0 && (
        <DataPoints items={path.dataPoints} />
      )}
    </div>
  );
}

function OperationsChapter({ operations }: { operations: Chapters['operations'] }) {
  const metrics = [
    { label: 'IRR', value: operations.irr },
    { label: 'Payback Period', value: operations.paybackPeriod },
    { label: 'Margins', value: operations.margins },
  ].filter(m => m.value);

  return (
    <div className="space-y-4">
      {metrics.length > 0 && (
        <div 
          className="grid grid-cols-3 gap-4 p-4 rounded-lg"
          style={{ backgroundColor: colors.slate[50] }}
        >
          {metrics.map((metric, index) => (
            <div key={index}>
              <span 
                className="text-xs font-medium uppercase tracking-wider block mb-1"
                style={{ color: colors.slate[500] }}
              >
                {metric.label}
              </span>
              <span 
                className="text-lg font-semibold"
                style={{ color: colors.navy }}
              >
                {metric.value}
              </span>
            </div>
          ))}
        </div>
      )}
      {operations.operationalRisks.length > 0 && (
        <Section title="Operational Risks" items={operations.operationalRisks} isWarning />
      )}
      {operations.dataPoints.length > 0 && (
        <DataPoints items={operations.dataPoints} />
      )}
    </div>
  );
}

function Section({ 
  title, 
  content, 
  items, 
  isWarning 
}: { 
  title: string; 
  content?: string; 
  items?: string[]; 
  isWarning?: boolean;
}) {
  return (
    <div>
      <h4 
        className="text-xs font-medium uppercase tracking-wider mb-2"
        style={{ color: colors.slate[500] }}
      >
        {title}
      </h4>
      {content && (
        <p 
          className="text-sm leading-relaxed"
          style={{ 
            color: colors.slate[600],
            lineHeight: typography.lineHeight.relaxed,
          }}
        >
          {content}
        </p>
      )}
      {items && items.length > 0 && (
        <ul className="space-y-1">
          {items.map((item, index) => (
            <li 
              key={index}
              className="flex items-start gap-2 text-sm"
            >
              <span 
                className="flex-shrink-0 mt-1.5 w-1.5 h-1.5 rounded-full"
                style={{ backgroundColor: isWarning ? colors.risk.amber : colors.slate[400] }}
              />
              <span 
                style={{ 
                  color: colors.slate[600],
                  lineHeight: typography.lineHeight.relaxed,
                }}
              >
                {item}
              </span>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}

function DataPoints({ items }: { items: string[] }) {
  if (items.length === 0) return null;
  
  return (
    <div 
      className="p-3 rounded-lg"
      style={{ backgroundColor: colors.slate[50] }}
    >
      <h4 
        className="text-xs font-medium uppercase tracking-wider mb-2"
        style={{ color: colors.slate[500] }}
      >
        Supporting Data
      </h4>
      <ul className="space-y-1">
        {items.map((item, index) => (
          <li 
            key={index}
            className="text-xs"
            style={{ color: colors.slate[500] }}
          >
            • {item}
          </li>
        ))}
      </ul>
    </div>
  );
}
</file>

<file path="components/infographic/ExecutiveNarrative.tsx">
'use client';

import { colors, typography } from '@/lib/infographic-styles';

interface ExecutiveNarrativeProps {
  narrative: string;
}

export function ExecutiveNarrative({ narrative }: ExecutiveNarrativeProps) {
  if (!narrative) return null;

  return (
    <div 
      className="avoid-break rounded-lg p-6"
      style={{ 
        backgroundColor: colors.slate[50],
        borderLeft: `4px solid ${colors.navy}`,
      }}
    >
      <div className="flex items-center gap-2 mb-3">
        <svg 
          className="w-5 h-5" 
          fill="none" 
          stroke="currentColor" 
          viewBox="0 0 24 24"
          style={{ color: colors.navy }}
        >
          <path 
            strokeLinecap="round" 
            strokeLinejoin="round" 
            strokeWidth={2} 
            d="M11 5.882V19.24a1.76 1.76 0 01-3.417.592l-2.147-6.15M18 13a3 3 0 100-6M5.436 13.683A4.001 4.001 0 017 6h1.832c4.1 0 7.625-1.234 9.168-3v14c-1.543-1.766-5.067-3-9.168-3H7a3.988 3.988 0 01-1.564-.317z" 
          />
        </svg>
        <h2 
          className="text-sm font-semibold uppercase tracking-wider"
          style={{ 
            color: colors.navy,
            fontFamily: typography.fontFamily.sans,
            fontWeight: typography.fontWeight.semibold,
          }}
        >
          Executive Summary
        </h2>
        <span 
          className="text-xs px-2 py-0.5 rounded-full ml-auto"
          style={{ 
            backgroundColor: colors.navy,
            color: colors.white,
          }}
        >
          AI Generated
        </span>
      </div>
      
      <p 
        className="text-base leading-relaxed"
        style={{ 
          color: colors.slate[700],
          lineHeight: typography.lineHeight.relaxed,
          fontStyle: 'italic',
        }}
      >
        &ldquo;{narrative}&rdquo;
      </p>
    </div>
  );
}
</file>

<file path="components/infographic/HeaderBanner.tsx">
'use client';

import { colors } from '@/lib/infographic-styles';

interface HeaderBannerProps {
  imageUrl?: string;
  projectName: string;
  industry: string;
}

export function HeaderBanner({ imageUrl, projectName, industry }: HeaderBannerProps) {
  if (!imageUrl) return null;

  return (
    <div 
      className="w-full h-48 rounded-t-lg relative overflow-hidden"
      style={{ backgroundColor: colors.slate[100] }}
    >
      <img
        src={imageUrl}
        alt={`${projectName} - ${industry}`}
        className="w-full h-full object-cover"
        onError={(e) => {
          // Hide the banner if image fails to load
          (e.target as HTMLElement).parentElement!.style.display = 'none';
        }}
      />
      {/* Gradient overlay for text readability */}
      <div 
        className="absolute inset-0"
        style={{ 
          background: `linear-gradient(to bottom, transparent 50%, ${colors.navy}99 100%)`,
        }}
      />
    </div>
  );
}
</file>

<file path="components/infographic/HighlightCards.tsx">
'use client';

import { Highlight } from '@/lib/schema';
import { colors, typography } from '@/lib/infographic-styles';

interface HighlightCardsProps {
  highlights: Highlight[];
}

export function HighlightCards({ highlights }: HighlightCardsProps) {
  if (highlights.length === 0) return null;

  return (
    <div className="avoid-break">
      <div className="flex items-center gap-2 mb-4">
        <div 
          className="w-1 h-6 rounded-full"
          style={{ backgroundColor: colors.navy }}
        />
        <h2 
          className="text-lg font-semibold"
          style={{ 
            color: colors.navy,
            fontFamily: typography.fontFamily.sans,
            fontWeight: typography.fontWeight.semibold,
          }}
        >
          Key Highlights
        </h2>
      </div>

      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
        {highlights.map((highlight, index) => (
          <div
            key={index}
            className="rounded-lg p-4"
            style={{ 
              backgroundColor: colors.white,
              border: `1px solid ${colors.slate[200]}`,
            }}
          >
            {/* Metric Name */}
            <span 
              className="text-xs font-medium uppercase tracking-wider block mb-2"
              style={{ color: colors.slate[500] }}
            >
              {highlight.metric}
            </span>
            
            {/* Value */}
            <span 
              className="text-2xl font-bold block mb-2"
              style={{ 
                color: colors.navy,
                fontWeight: typography.fontWeight.bold,
              }}
            >
              {highlight.value}
            </span>
            
            {/* Context */}
            <span 
              className="text-sm leading-relaxed"
              style={{ 
                color: colors.slate[500],
                lineHeight: typography.lineHeight.relaxed,
              }}
            >
              {highlight.context}
            </span>
          </div>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="components/infographic/index.ts">
/**
 * Infographic Components Barrel Export
 * 
 * All components for rendering investment memo infographics.
 */

export { InfographicContainer } from './InfographicContainer';
export { InfographicHeader } from './InfographicHeader';
export { VerdictCard } from './VerdictCard';
export { SixTRadar } from './SixTRadar';
export { HighlightCards } from './HighlightCards';
export { AssumptionsList } from './AssumptionsList';
export { VerdictPair } from './VerdictPair';
export { NextStepsTimeline } from './NextStepsTimeline';
export { ChapterSummaries } from './ChapterSummaries';
export { ExecutiveNarrative } from './ExecutiveNarrative';
export { HeaderBanner } from './HeaderBanner';
</file>

<file path="components/infographic/InfographicContainer.tsx">
'use client';

import { useRef } from 'react';
import { ExtractionResult } from '@/lib/schema';
import { colors, typography } from '@/lib/infographic-styles';
import { InfographicHeader } from './InfographicHeader';
import { ExecutiveNarrative } from './ExecutiveNarrative';
import { VerdictCard } from './VerdictCard';
import { SixTRadar } from './SixTRadar';
import { HighlightCards } from './HighlightCards';
import { AssumptionsList } from './AssumptionsList';
import { VerdictPair } from './VerdictPair';
import { NextStepsTimeline } from './NextStepsTimeline';
import { ChapterSummaries } from './ChapterSummaries';

interface InfographicContainerProps {
  data: ExtractionResult;
  narrative?: string;
  headerImage?: string;
  onCopyHtml?: () => void;
}

export function InfographicContainer({ 
  data, 
  narrative, 
  headerImage,
  onCopyHtml,
}: InfographicContainerProps) {
  const containerRef = useRef<HTMLDivElement>(null);

  const handlePrint = () => {
    window.print();
  };

  const handleCopyHtml = () => {
    if (containerRef.current) {
      const html = containerRef.current.outerHTML;
      navigator.clipboard.writeText(html).then(() => {
        onCopyHtml?.();
      });
    }
  };

  return (
    <div className="w-full">
      {/* Action Buttons - Hidden in Print */}
      <div className="flex items-center justify-between mb-6 no-print">
        <div className="flex items-center gap-2">
          <span 
            className="text-sm font-medium"
            style={{ color: colors.slate[600] }}
          >
            Investment Infographic
          </span>
          <span 
            className="text-xs px-2 py-0.5 rounded"
            style={{ 
              backgroundColor: colors.slate[100],
              color: colors.slate[500],
            }}
          >
            Confidence: {data.confidence}%
          </span>
        </div>
        <div className="flex items-center gap-2">
          <button
            onClick={handleCopyHtml}
            className="flex items-center gap-2 px-3 py-2 text-sm font-medium rounded-lg transition-colors"
            style={{ 
              backgroundColor: colors.white,
              border: `1px solid ${colors.slate[300]}`,
              color: colors.slate[700],
            }}
          >
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
            </svg>
            Copy HTML
          </button>
          <button
            onClick={handlePrint}
            className="flex items-center gap-2 px-3 py-2 text-sm font-medium rounded-lg transition-colors"
            style={{ 
              backgroundColor: colors.navy,
              color: colors.white,
            }}
          >
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 17h2a2 2 0 002-2v-4a2 2 0 00-2-2H5a2 2 0 00-2 2v4a2 2 0 002 2h2m2 4h6a2 2 0 002-2v-4a2 2 0 00-2-2H9a2 2 0 00-2 2v4a2 2 0 002 2zm8-12V5a2 2 0 00-2-2H9a2 2 0 00-2 2v4h10z" />
            </svg>
            Download as PDF
          </button>
        </div>
      </div>

      {/* Infographic Content */}
      <div 
        ref={containerRef}
        className="infographic rounded-lg overflow-hidden"
        style={{ 
          backgroundColor: colors.white,
          fontFamily: typography.fontFamily.sans,
        }}
      >
        {/* Page 1: Header, Summary, Radar, Highlights */}
        <div className="infographic-page-1">
          {/* Header with optional banner image */}
          <InfographicHeader 
            metadata={data.metadata} 
            headerImage={headerImage}
          />

          {/* Optional AI Narrative */}
          {narrative && (
            <div className="p-6 pt-0">
              <div className="mt-6">
                <ExecutiveNarrative narrative={narrative} />
              </div>
            </div>
          )}

          {/* Main Content Grid */}
          <div className="p-6 space-y-6">
            {/* Executive Summary */}
            <VerdictCard executiveSummary={data.executiveSummary} />

            {/* Strategic Fit */}
            <div 
              className="avoid-break rounded-lg p-4"
              style={{ 
                backgroundColor: colors.slate[50],
                border: `1px solid ${colors.slate[200]}`,
              }}
            >
              <div className="flex items-center justify-between">
                <div>
                  <span 
                    className="text-xs font-medium uppercase tracking-wider block mb-1"
                    style={{ color: colors.slate[500] }}
                  >
                    Strategic Fit Assessment
                  </span>
                  <p 
                    className="text-sm"
                    style={{ color: colors.slate[700] }}
                  >
                    {data.strategicFit.assessment}
                  </p>
                </div>
                <span 
                  className="px-3 py-1 rounded-full text-xs font-medium flex-shrink-0 ml-4"
                  style={{ 
                    backgroundColor: data.strategicFit.confidenceLevel === 'High' 
                      ? colors.risk.greenLight 
                      : data.strategicFit.confidenceLevel === 'Medium'
                        ? colors.risk.amberLight
                        : colors.risk.redLight,
                    color: data.strategicFit.confidenceLevel === 'High' 
                      ? colors.risk.green 
                      : data.strategicFit.confidenceLevel === 'Medium'
                        ? colors.risk.amber
                        : colors.risk.red,
                  }}
                >
                  {data.strategicFit.confidenceLevel} Confidence
                </span>
              </div>
            </div>

            {/* Six-T Radar */}
            <SixTRadar risks={data.sixTRisks} />

            {/* Highlights */}
            <HighlightCards highlights={data.highlights} />
          </div>
        </div>

        {/* Page 2: Assumptions, Verdicts, Next Steps, Chapters */}
        <div className="infographic-page-2 page-break-before">
          <div className="p-6 space-y-6">
            {/* Critical Assumptions */}
            <AssumptionsList assumptions={data.criticalAssumptions} />

            {/* Verdict Pair */}
            <VerdictPair 
              shouldWeDoIt={data.shouldWeDoIt} 
              canWeDoIt={data.canWeDoIt} 
            />

            {/* Next Steps */}
            <NextStepsTimeline nextSteps={data.nextSteps} />

            {/* Chapter Summaries */}
            <ChapterSummaries chapters={data.chapters} />
          </div>
        </div>

        {/* Footer */}
        <div 
          className="px-6 py-4 mt-6"
          style={{ 
            backgroundColor: colors.slate[50],
            borderTop: `1px solid ${colors.slate[200]}`,
          }}
        >
          <div className="flex items-center justify-between text-xs" style={{ color: colors.slate[500] }}>
            <span>Generated by The Olsenator — Innovera Investment Analysis Platform</span>
            <span>{new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}</span>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/infographic/InfographicHeader.tsx">
'use client';

import { ProjectMetadata } from '@/lib/schema';
import { colors, typography, getDecisionColor, getDecisionBgColor } from '@/lib/infographic-styles';

interface InfographicHeaderProps {
  metadata: ProjectMetadata;
  headerImage?: string;
}

export function InfographicHeader({ metadata, headerImage }: InfographicHeaderProps) {
  const decisionColor = getDecisionColor(metadata.decision);
  const decisionBgColor = getDecisionBgColor(metadata.decision);

  return (
    <div className="infographic-header avoid-break">
      {/* Optional AI-generated header image */}
      {headerImage && (
        <div 
          className="w-full h-32 bg-cover bg-center rounded-t-lg"
          style={{ 
            backgroundImage: `url(${headerImage})`,
            backgroundColor: colors.slate[100],
          }}
        />
      )}
      
      <div 
        className="p-6 rounded-lg"
        style={{ 
          backgroundColor: colors.navy,
          borderTopLeftRadius: headerImage ? 0 : undefined,
          borderTopRightRadius: headerImage ? 0 : undefined,
        }}
      >
        <div className="flex flex-col md:flex-row md:items-start md:justify-between gap-4">
          {/* Project Info */}
          <div className="flex-1">
            <h1 
              className="text-3xl font-bold mb-2"
              style={{ 
                color: colors.white,
                fontFamily: typography.fontFamily.sans,
                fontWeight: typography.fontWeight.bold,
              }}
            >
              {metadata.projectName}
            </h1>
            
            <div className="flex flex-wrap items-center gap-3 mt-3">
              {/* Stage Badge */}
              <span 
                className="px-3 py-1 rounded-full text-sm font-medium"
                style={{ 
                  backgroundColor: 'rgba(255, 255, 255, 0.15)',
                  color: colors.white,
                }}
              >
                {metadata.stage}
              </span>
              
              {/* Industry */}
              <span 
                className="text-sm"
                style={{ color: colors.slate[300] }}
              >
                {metadata.industry}
              </span>
              
              {/* Location */}
              {metadata.location && (
                <>
                  <span style={{ color: colors.slate[500] }}>•</span>
                  <span 
                    className="text-sm"
                    style={{ color: colors.slate[300] }}
                  >
                    {metadata.location}
                  </span>
                </>
              )}
            </div>
          </div>
          
          {/* Decision Indicator */}
          <div 
            className="flex flex-col items-center justify-center px-6 py-4 rounded-lg min-w-[160px]"
            style={{ backgroundColor: decisionBgColor }}
          >
            <span 
              className="text-xs font-medium uppercase tracking-wider mb-1"
              style={{ color: colors.slate[500] }}
            >
              Recommendation
            </span>
            <span 
              className="text-lg font-bold"
              style={{ 
                color: decisionColor,
                fontWeight: typography.fontWeight.bold,
              }}
            >
              {metadata.decision}
            </span>
          </div>
        </div>
        
        {/* Recommendation Text */}
        {metadata.recommendation && (
          <p 
            className="mt-4 text-sm leading-relaxed"
            style={{ 
              color: colors.slate[300],
              lineHeight: typography.lineHeight.relaxed,
            }}
          >
            {metadata.recommendation}
          </p>
        )}
      </div>
    </div>
  );
}
</file>

<file path="components/infographic/NextStepsTimeline.tsx">
'use client';

import { NextStep } from '@/lib/schema';
import { colors, typography } from '@/lib/infographic-styles';

interface NextStepsTimelineProps {
  nextSteps: NextStep[];
}

export function NextStepsTimeline({ nextSteps }: NextStepsTimelineProps) {
  if (nextSteps.length === 0) return null;

  return (
    <div 
      className="avoid-break rounded-lg p-6"
      style={{ 
        backgroundColor: colors.white,
        border: `1px solid ${colors.slate[200]}`,
      }}
    >
      <div className="flex items-center gap-2 mb-4">
        <div 
          className="w-1 h-6 rounded-full"
          style={{ backgroundColor: colors.navy }}
        />
        <h2 
          className="text-lg font-semibold"
          style={{ 
            color: colors.navy,
            fontFamily: typography.fontFamily.sans,
            fontWeight: typography.fontWeight.semibold,
          }}
        >
          Recommended Next Steps
        </h2>
      </div>

      <div className="relative">
        {nextSteps.map((step, index) => (
          <div 
            key={index}
            className="relative pl-8 pb-6 last:pb-0"
          >
            {/* Timeline Line */}
            {index < nextSteps.length - 1 && (
              <div 
                className="absolute left-3 top-6 bottom-0 w-0.5"
                style={{ backgroundColor: colors.slate[200] }}
              />
            )}
            
            {/* Timeline Node */}
            <div 
              className="absolute left-0 top-0 w-6 h-6 rounded-full flex items-center justify-center text-xs font-semibold"
              style={{ 
                backgroundColor: colors.navy,
                color: colors.white,
              }}
            >
              {index + 1}
            </div>

            {/* Content */}
            <div 
              className="rounded-lg p-4 ml-2"
              style={{ backgroundColor: colors.slate[50] }}
            >
              {/* Action */}
              <h4 
                className="text-sm font-semibold mb-2"
                style={{ 
                  color: colors.slate[700],
                  fontWeight: typography.fontWeight.semibold,
                }}
              >
                {step.action}
              </h4>

              {/* Rationale */}
              {step.rationale && (
                <p 
                  className="text-sm mb-3"
                  style={{ 
                    color: colors.slate[600],
                    lineHeight: typography.lineHeight.relaxed,
                  }}
                >
                  {step.rationale}
                </p>
              )}

              {/* Success Gate */}
              <div 
                className="flex items-start gap-2 pt-2"
                style={{ borderTop: `1px solid ${colors.slate[200]}` }}
              >
                <svg 
                  className="w-4 h-4 flex-shrink-0 mt-0.5" 
                  fill="none" 
                  stroke="currentColor" 
                  viewBox="0 0 24 24"
                  style={{ color: colors.risk.green }}
                >
                  <path 
                    strokeLinecap="round" 
                    strokeLinejoin="round" 
                    strokeWidth={2} 
                    d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" 
                  />
                </svg>
                <div>
                  <span 
                    className="text-xs font-medium uppercase tracking-wider block mb-0.5"
                    style={{ color: colors.slate[500] }}
                  >
                    Success Gate
                  </span>
                  <span 
                    className="text-sm"
                    style={{ color: colors.slate[600] }}
                  >
                    {step.successGate}
                  </span>
                </div>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="components/infographic/SixTRadar.tsx">
'use client';

import { SixTRisks, RiskRating } from '@/lib/schema';
import { colors, typography, radarConfig, getRiskColor } from '@/lib/infographic-styles';

interface SixTRadarProps {
  risks: SixTRisks;
}

// Calculate point on hexagon at given angle and radius
function getPoint(centerX: number, centerY: number, angle: number, radius: number): { x: number; y: number } {
  // Offset by -90 degrees so first axis points up
  const adjustedAngle = angle - Math.PI / 2;
  return {
    x: centerX + radius * Math.cos(adjustedAngle),
    y: centerY + radius * Math.sin(adjustedAngle),
  };
}

// Generate hexagon path
function generateHexagonPath(centerX: number, centerY: number, radius: number): string {
  const points: { x: number; y: number }[] = [];
  for (let i = 0; i < 6; i++) {
    const angle = (i * Math.PI * 2) / 6;
    points.push(getPoint(centerX, centerY, angle, radius));
  }
  return points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ') + ' Z';
}

// Generate radar polygon based on ratings
function generateRadarPolygon(
  centerX: number, 
  centerY: number, 
  maxRadius: number, 
  ratings: RiskRating[]
): string {
  const points: { x: number; y: number }[] = [];
  for (let i = 0; i < 6; i++) {
    const angle = (i * Math.PI * 2) / 6;
    const rating = ratings[i];
    const radiusMultiplier = radarConfig.ratingToRadius[rating];
    const radius = maxRadius * radiusMultiplier;
    points.push(getPoint(centerX, centerY, angle, radius));
  }
  return points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ') + ' Z';
}

export function SixTRadar({ risks }: SixTRadarProps) {
  const { size, centerX, centerY, maxRadius, axes } = radarConfig;
  
  // Map risks to array in correct order
  const riskEntries: { name: string; rating: RiskRating; summary: string }[] = [
    { name: 'Team', rating: risks.team.rating, summary: risks.team.summary },
    { name: 'TAM', rating: risks.tam.rating, summary: risks.tam.summary },
    { name: 'Technology', rating: risks.technology.rating, summary: risks.technology.summary },
    { name: 'Traction', rating: risks.traction.rating, summary: risks.traction.summary },
    { name: 'Terms', rating: risks.terms.rating, summary: risks.terms.summary },
    { name: 'Trends', rating: risks.trends.rating, summary: risks.trends.summary },
  ];
  
  const ratings = riskEntries.map(r => r.rating);
  
  // Calculate label positions (slightly outside the hexagon)
  const labelRadius = maxRadius + 30;
  const labelPositions = axes.map((_, i) => {
    const angle = (i * Math.PI * 2) / 6;
    return getPoint(centerX, centerY, angle, labelRadius);
  });

  return (
    <div 
      className="avoid-break rounded-lg p-6"
      style={{ 
        backgroundColor: colors.white,
        border: `1px solid ${colors.slate[200]}`,
      }}
    >
      <div className="flex items-center gap-2 mb-4">
        <div 
          className="w-1 h-6 rounded-full"
          style={{ backgroundColor: colors.navy }}
        />
        <h2 
          className="text-lg font-semibold"
          style={{ 
            color: colors.navy,
            fontFamily: typography.fontFamily.sans,
            fontWeight: typography.fontWeight.semibold,
          }}
        >
          Six-T Risk Analysis
        </h2>
      </div>

      <div className="flex flex-col lg:flex-row items-center gap-6">
        {/* SVG Radar Chart */}
        <div className="relative flex-shrink-0">
          <svg 
            width={size} 
            height={size} 
            viewBox={`0 0 ${size} ${size}`}
            className="overflow-visible"
          >
            {/* Background hexagons (grid lines) */}
            {[1, 0.6, 0.3].map((scale, i) => (
              <path
                key={i}
                d={generateHexagonPath(centerX, centerY, maxRadius * scale)}
                fill="none"
                stroke={colors.slate[200]}
                strokeWidth={1}
              />
            ))}
            
            {/* Axis lines */}
            {axes.map((_, i) => {
              const angle = (i * Math.PI * 2) / 6;
              const endPoint = getPoint(centerX, centerY, angle, maxRadius);
              return (
                <line
                  key={i}
                  x1={centerX}
                  y1={centerY}
                  x2={endPoint.x}
                  y2={endPoint.y}
                  stroke={colors.slate[200]}
                  strokeWidth={1}
                />
              );
            })}
            
            {/* Radar fill polygon */}
            <path
              d={generateRadarPolygon(centerX, centerY, maxRadius, ratings)}
              fill={colors.navy}
              fillOpacity={0.15}
              stroke={colors.navy}
              strokeWidth={2}
            />
            
            {/* Data points with color indicators */}
            {riskEntries.map((entry, i) => {
              const angle = (i * Math.PI * 2) / 6;
              const radiusMultiplier = radarConfig.ratingToRadius[entry.rating];
              const radius = maxRadius * radiusMultiplier;
              const point = getPoint(centerX, centerY, angle, radius);
              const riskColor = getRiskColor(entry.rating);
              
              return (
                <g key={i}>
                  {/* Outer ring */}
                  <circle
                    cx={point.x}
                    cy={point.y}
                    r={10}
                    fill={colors.white}
                    stroke={riskColor}
                    strokeWidth={3}
                  />
                  {/* Inner dot */}
                  <circle
                    cx={point.x}
                    cy={point.y}
                    r={4}
                    fill={riskColor}
                  />
                </g>
              );
            })}
            
            {/* Axis labels */}
            {axes.map((label, i) => {
              const pos = labelPositions[i];
              // Determine text anchor based on position
              let textAnchor: 'start' | 'middle' | 'end' = 'middle';
              if (i === 1 || i === 2) textAnchor = 'start';
              if (i === 4 || i === 5) textAnchor = 'end';
              
              return (
                <text
                  key={i}
                  x={pos.x}
                  y={pos.y}
                  textAnchor={textAnchor}
                  dominantBaseline="middle"
                  fill={colors.slate[600]}
                  fontSize="12"
                  fontWeight="500"
                  fontFamily={typography.fontFamily.sans}
                >
                  {label}
                </text>
              );
            })}
          </svg>
        </div>
        
        {/* Risk Summaries */}
        <div className="flex-1 grid grid-cols-1 sm:grid-cols-2 gap-3">
          {riskEntries.map((entry, i) => {
            const riskColor = getRiskColor(entry.rating);
            return (
              <div 
                key={i}
                className="flex items-start gap-3 p-3 rounded-lg"
                style={{ backgroundColor: colors.slate[50] }}
              >
                <div 
                  className="flex-shrink-0 w-3 h-3 rounded-full mt-1"
                  style={{ backgroundColor: riskColor }}
                />
                <div>
                  <span 
                    className="text-sm font-medium block"
                    style={{ color: colors.slate[700] }}
                  >
                    {entry.name}
                  </span>
                  <span 
                    className="text-xs leading-relaxed"
                    style={{ color: colors.slate[500] }}
                  >
                    {entry.summary}
                  </span>
                </div>
              </div>
            );
          })}
        </div>
      </div>
      
      {/* Legend */}
      <div 
        className="flex items-center justify-center gap-6 mt-6 pt-4"
        style={{ borderTop: `1px solid ${colors.slate[200]}` }}
      >
        <div className="flex items-center gap-2">
          <div 
            className="w-3 h-3 rounded-full"
            style={{ backgroundColor: colors.risk.green }}
          />
          <span className="text-xs" style={{ color: colors.slate[500] }}>Low Risk</span>
        </div>
        <div className="flex items-center gap-2">
          <div 
            className="w-3 h-3 rounded-full"
            style={{ backgroundColor: colors.risk.amber }}
          />
          <span className="text-xs" style={{ color: colors.slate[500] }}>Medium Risk</span>
        </div>
        <div className="flex items-center gap-2">
          <div 
            className="w-3 h-3 rounded-full"
            style={{ backgroundColor: colors.risk.red }}
          />
          <span className="text-xs" style={{ color: colors.slate[500] }}>High Risk</span>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/infographic/VerdictCard.tsx">
'use client';

import { ExecutiveSummary } from '@/lib/schema';
import { colors, typography, spacing } from '@/lib/infographic-styles';

interface VerdictCardProps {
  executiveSummary: ExecutiveSummary;
}

export function VerdictCard({ executiveSummary }: VerdictCardProps) {
  return (
    <div 
      className="avoid-break rounded-lg p-6"
      style={{ 
        backgroundColor: colors.white,
        border: `1px solid ${colors.slate[200]}`,
      }}
    >
      <div className="flex items-center gap-2 mb-4">
        <div 
          className="w-1 h-6 rounded-full"
          style={{ backgroundColor: colors.navy }}
        />
        <h2 
          className="text-lg font-semibold"
          style={{ 
            color: colors.navy,
            fontFamily: typography.fontFamily.sans,
            fontWeight: typography.fontWeight.semibold,
          }}
        >
          Tell It To Me Straight
        </h2>
      </div>
      
      {/* Main Verdict */}
      <p 
        className="text-xl font-medium leading-relaxed mb-6"
        style={{ 
          color: colors.slate[700],
          fontWeight: typography.fontWeight.medium,
          lineHeight: typography.lineHeight.relaxed,
        }}
      >
        {executiveSummary.verdict}
      </p>
      
      {/* Core Reasoning Points */}
      {executiveSummary.coreReasoning.length > 0 && (
        <div>
          <h3 
            className="text-sm font-medium uppercase tracking-wider mb-3"
            style={{ color: colors.slate[500] }}
          >
            Key Takeaways
          </h3>
          <ul className="space-y-2">
            {executiveSummary.coreReasoning.map((reason, index) => (
              <li 
                key={index}
                className="flex items-start gap-3"
              >
                <span 
                  className="flex-shrink-0 w-5 h-5 rounded-full flex items-center justify-center text-xs font-medium mt-0.5"
                  style={{ 
                    backgroundColor: colors.slate[100],
                    color: colors.slate[600],
                  }}
                >
                  {index + 1}
                </span>
                <span 
                  className="text-sm leading-relaxed"
                  style={{ 
                    color: colors.slate[600],
                    lineHeight: typography.lineHeight.relaxed,
                  }}
                >
                  {reason}
                </span>
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/infographic/VerdictPair.tsx">
'use client';

import { Verdict } from '@/lib/schema';
import { colors, typography, getConfidenceColor } from '@/lib/infographic-styles';

interface VerdictPairProps {
  shouldWeDoIt: Verdict;
  canWeDoIt: Verdict;
}

export function VerdictPair({ shouldWeDoIt, canWeDoIt }: VerdictPairProps) {
  return (
    <div className="avoid-break">
      <div className="flex items-center gap-2 mb-4">
        <div 
          className="w-1 h-6 rounded-full"
          style={{ backgroundColor: colors.navy }}
        />
        <h2 
          className="text-lg font-semibold"
          style={{ 
            color: colors.navy,
            fontFamily: typography.fontFamily.sans,
            fontWeight: typography.fontWeight.semibold,
          }}
        >
          Investment Assessment
        </h2>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <VerdictPanel 
          title="Should We Do It?" 
          verdict={shouldWeDoIt}
          icon={
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          }
        />
        <VerdictPanel 
          title="Can We Do It?" 
          verdict={canWeDoIt}
          icon={
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
          }
        />
      </div>
    </div>
  );
}

interface VerdictPanelProps {
  title: string;
  verdict: Verdict;
  icon: React.ReactNode;
}

function VerdictPanel({ title, verdict, icon }: VerdictPanelProps) {
  const confidenceColor = getConfidenceColor(verdict.confidenceLevel);

  return (
    <div 
      className="rounded-lg p-5"
      style={{ 
        backgroundColor: colors.white,
        border: `1px solid ${colors.slate[200]}`,
      }}
    >
      {/* Header */}
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center gap-2">
          <span style={{ color: colors.navy }}>{icon}</span>
          <h3 
            className="text-sm font-semibold"
            style={{ 
              color: colors.navy,
              fontWeight: typography.fontWeight.semibold,
            }}
          >
            {title}
          </h3>
        </div>
        
        {/* Confidence Badge */}
        <span 
          className="px-2 py-1 rounded text-xs font-medium"
          style={{ 
            backgroundColor: `${confidenceColor}15`,
            color: confidenceColor,
          }}
        >
          {verdict.confidenceLevel} Confidence
        </span>
      </div>

      {/* Verdict */}
      <p 
        className="text-base font-medium mb-4"
        style={{ 
          color: colors.slate[700],
          fontWeight: typography.fontWeight.medium,
          lineHeight: typography.lineHeight.relaxed,
        }}
      >
        {verdict.verdict}
      </p>

      {/* Supporting Factors */}
      {verdict.supportingFactors.length > 0 && (
        <div>
          <h4 
            className="text-xs font-medium uppercase tracking-wider mb-2"
            style={{ color: colors.slate[500] }}
          >
            Supporting Factors
          </h4>
          <ul className="space-y-2">
            {verdict.supportingFactors.map((factor, index) => (
              <li 
                key={index}
                className="flex items-start gap-2 text-sm"
              >
                <span 
                  className="flex-shrink-0 mt-1.5 w-1.5 h-1.5 rounded-full"
                  style={{ backgroundColor: colors.slate[400] }}
                />
                <span 
                  style={{ 
                    color: colors.slate[600],
                    lineHeight: typography.lineHeight.relaxed,
                  }}
                >
                  {factor}
                </span>
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}
</file>

<file path="lib/infographic-styles.ts">
/**
 * Design System for Infographic Rendering
 * 
 * Strict design system for visual consistency across all generated infographics.
 * Optimized for both screen viewing and print-to-PDF output.
 */

export const colors = {
  // Primary colors
  navy: '#1e293b',
  white: '#ffffff',
  
  // Slate hierarchy for text
  slate: {
    900: '#0f172a',  // Darkest headings
    700: '#334155',  // Primary body text
    600: '#475569',  // Secondary body text
    500: '#64748b',  // Tertiary text
    400: '#94a3b8',  // Muted text
    300: '#cbd5e1',  // Borders
    200: '#e2e8f0',  // Light borders
    100: '#f1f5f9',  // Background accent
    50: '#f8fafc',   // Lightest background
  },
  
  // Risk indicator colors (Six-T)
  risk: {
    red: '#ef4444',
    redLight: '#fef2f2',
    redBorder: '#fecaca',
    amber: '#f59e0b',
    amberLight: '#fffbeb',
    amberBorder: '#fde68a',
    green: '#22c55e',
    greenLight: '#f0fdf4',
    greenBorder: '#bbf7d0',
  },
  
  // Confidence level colors
  confidence: {
    high: '#22c55e',
    medium: '#f59e0b',
    low: '#ef4444',
  },
  
  // Decision colors
  decision: {
    proceed: '#22c55e',
    proceedBg: '#f0fdf4',
    conditional: '#f59e0b',
    conditionalBg: '#fffbeb',
    doNotProceed: '#ef4444',
    doNotProceedBg: '#fef2f2',
  },
  
  // Assumption status colors
  assumption: {
    validated: '#22c55e',
    validatedBg: '#f0fdf4',
    pending: '#f59e0b',
    pendingBg: '#fffbeb',
    atRisk: '#ef4444',
    atRiskBg: '#fef2f2',
  },
} as const;

export const spacing = {
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32,
  '2xl': 48,
  '3xl': 64,
} as const;

export const typography = {
  fontFamily: {
    sans: 'Inter, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
    mono: 'ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, monospace',
  },
  fontSize: {
    xs: '0.75rem',     // 12px
    sm: '0.875rem',    // 14px
    base: '1rem',      // 16px
    lg: '1.125rem',    // 18px
    xl: '1.25rem',     // 20px
    '2xl': '1.5rem',   // 24px
    '3xl': '1.875rem', // 30px
    '4xl': '2.25rem',  // 36px
  },
  fontWeight: {
    normal: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
  },
  lineHeight: {
    tight: 1.25,
    normal: 1.5,
    relaxed: 1.75,
  },
} as const;

export const borderRadius = {
  sm: '4px',
  md: '8px',
  lg: '12px',
  xl: '16px',
  full: '9999px',
} as const;

export const shadows = {
  sm: '0 1px 2px 0 rgb(0 0 0 / 0.05)',
  md: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
  lg: '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)',
} as const;

// Six-T radar chart configuration
export const radarConfig = {
  size: 300,
  centerX: 150,
  centerY: 150,
  maxRadius: 120,
  axes: ['Team', 'TAM', 'Technology', 'Traction', 'Terms', 'Trends'] as const,
  ratingToRadius: {
    green: 1.0,   // 100% of maxRadius
    yellow: 0.6,  // 60% of maxRadius
    red: 0.3,     // 30% of maxRadius
  },
} as const;

// Helper functions
export function getDecisionColor(decision: string): string {
  switch (decision) {
    case 'Proceed':
      return colors.decision.proceed;
    case 'Do Not Proceed':
      return colors.decision.doNotProceed;
    case 'Conditional':
      return colors.decision.conditional;
    default:
      return colors.slate[500];
  }
}

export function getDecisionBgColor(decision: string): string {
  switch (decision) {
    case 'Proceed':
      return colors.decision.proceedBg;
    case 'Do Not Proceed':
      return colors.decision.doNotProceedBg;
    case 'Conditional':
      return colors.decision.conditionalBg;
    default:
      return colors.slate[100];
  }
}

export function getRiskColor(rating: string): string {
  switch (rating) {
    case 'green':
      return colors.risk.green;
    case 'yellow':
      return colors.risk.amber;
    case 'red':
      return colors.risk.red;
    default:
      return colors.slate[400];
  }
}

export function getConfidenceColor(level: string): string {
  switch (level) {
    case 'High':
      return colors.confidence.high;
    case 'Medium':
      return colors.confidence.medium;
    case 'Low':
      return colors.confidence.low;
    default:
      return colors.slate[400];
  }
}

export function getAssumptionColor(status: string): string {
  switch (status) {
    case 'validated':
      return colors.assumption.validated;
    case 'pending':
      return colors.assumption.pending;
    case 'at-risk':
      return colors.assumption.atRisk;
    default:
      return colors.slate[400];
  }
}

export function getAssumptionBgColor(status: string): string {
  switch (status) {
    case 'validated':
      return colors.assumption.validatedBg;
    case 'pending':
      return colors.assumption.pendingBg;
    case 'at-risk':
      return colors.assumption.atRiskBg;
    default:
      return colors.slate[100];
  }
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="app/api/extract/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { extractMemoData } from '@/lib/openrouter';

export const maxDuration = 60; // Allow up to 60 seconds for extraction

interface ExtractRequest {
  memo: string;
}

export async function POST(request: NextRequest) {
  try {
    const body: ExtractRequest = await request.json();

    if (!body.memo || typeof body.memo !== 'string') {
      return NextResponse.json(
        { success: false, error: 'Missing or invalid memo content' },
        { status: 400 }
      );
    }

    if (body.memo.trim().length < 100) {
      return NextResponse.json(
        { success: false, error: 'Memo content is too short. Please paste the full investment memo.' },
        { status: 400 }
      );
    }

    const apiKey = process.env.OPENROUTER_API_KEY;

    if (!apiKey) {
      console.error('OPENROUTER_API_KEY is not configured');
      return NextResponse.json(
        { success: false, error: 'Server configuration error: API key not configured' },
        { status: 500 }
      );
    }

    console.log(`Processing memo extraction (${body.memo.length} characters)...`);
    const startTime = Date.now();

    const result = await extractMemoData(body.memo, apiKey);

    const duration = Date.now() - startTime;
    console.log(`Extraction completed in ${duration}ms, success: ${result.success}`);

    if (!result.success) {
      console.error('Extraction failed:', result.error);
      return NextResponse.json(
        { 
          success: false, 
          error: result.error,
          retried: result.retried 
        },
        { status: 422 }
      );
    }

    return NextResponse.json({
      success: true,
      data: result.data,
      retried: result.retried,
      duration,
    });
  } catch (error) {
    console.error('Unexpected error in extract route:', error);
    return NextResponse.json(
      { 
        success: false, 
        error: error instanceof Error ? error.message : 'An unexpected error occurred' 
      },
      { status: 500 }
    );
  }
}
</file>

<file path="app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #0a0a0a;
  --foreground: #ededed;
  --accent: #3b82f6;
  --accent-hover: #2563eb;
  --surface: #141414;
  --surface-hover: #1a1a1a;
  --border: #2a2a2a;
  --muted: #737373;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: var(--font-geist-sans), system-ui, sans-serif;
}

/* Custom scrollbar for dark theme */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--surface);
}

::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--muted);
}

/* Textarea styling */
textarea {
  scrollbar-width: thin;
  scrollbar-color: var(--border) var(--surface);
}

/* ==========================================================================
   Print Styles for Infographic Export
   ========================================================================== */

@media print {
  /* Reset background and colors for print */
  body {
    background: white !important;
    color: black !important;
    -webkit-print-color-adjust: exact !important;
    print-color-adjust: exact !important;
  }

  /* Hide UI chrome - header, footer, buttons, navigation */
  .no-print,
  header,
  footer,
  button,
  .no-print-bg {
    display: none !important;
  }

  /* Ensure infographic backgrounds print correctly */
  .infographic,
  .infographic * {
    -webkit-print-color-adjust: exact !important;
    print-color-adjust: exact !important;
  }

  /* Page setup */
  @page {
    size: A4;
    margin: 15mm 10mm;
  }

  /* Page break controls */
  .page-break-before {
    page-break-before: always !important;
    break-before: page !important;
  }

  .page-break-after {
    page-break-after: always !important;
    break-after: page !important;
  }

  .avoid-break {
    page-break-inside: avoid !important;
    break-inside: avoid !important;
  }

  /* Infographic container - full width for print */
  .infographic {
    width: 100% !important;
    max-width: 100% !important;
    margin: 0 !important;
    padding: 0 !important;
    box-shadow: none !important;
    border: none !important;
  }

  /* Ensure SVG radar chart prints correctly */
  svg {
    -webkit-print-color-adjust: exact !important;
    print-color-adjust: exact !important;
  }

  /* Force colored backgrounds to print */
  [style*="background"] {
    -webkit-print-color-adjust: exact !important;
    print-color-adjust: exact !important;
  }

  /* Grid layouts for print */
  .grid {
    display: grid !important;
  }

  /* Ensure links don't show URLs */
  a[href]:after {
    content: none !important;
  }

  /* Print-only content */
  .print-only {
    display: block !important;
  }

  /* Hide interactive elements */
  .no-print button,
  .no-print input,
  .no-print textarea,
  .no-print select {
    display: none !important;
  }

  /* Improve text rendering */
  * {
    text-shadow: none !important;
  }

  /* Ensure images print */
  img {
    max-width: 100% !important;
    page-break-inside: avoid !important;
  }

  /* Header section - keep together */
  .infographic-header {
    page-break-inside: avoid !important;
    break-inside: avoid !important;
  }

  /* Page 1 content */
  .infographic-page-1 {
    page-break-after: auto;
  }

  /* Page 2 content */
  .infographic-page-2 {
    page-break-before: always !important;
  }

  /* Cards should not break */
  [class*="Card"],
  [class*="card"] {
    page-break-inside: avoid !important;
    break-inside: avoid !important;
  }

  /* Timeline items should not break */
  .timeline-item {
    page-break-inside: avoid !important;
  }

  /* Ensure proper spacing */
  .space-y-6 > * + * {
    margin-top: 1.5rem !important;
  }

  /* Fix flexbox for print */
  .flex {
    display: flex !important;
  }

  /* Ensure rounded corners show in print */
  .rounded-lg {
    border-radius: 0.5rem !important;
  }
}

/* Screen-only content (hidden in print) */
@media screen {
  .print-only {
    display: none !important;
  }
}
</file>

<file path="app/layout.tsx">
import type { Metadata } from "next";
import { Inter, JetBrains_Mono } from "next/font/google";
import "./globals.css";

const inter = Inter({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const jetbrainsMono = JetBrains_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "The Olsenator — Extraction Engine",
  description: "Transform investment memos into structured JSON data",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${inter.variable} ${jetbrainsMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
</file>

<file path="app/page.tsx">
'use client';

import { useState, useRef } from 'react';
import { MemoInput } from '@/components/MemoInput';
import { JsonOutput } from '@/components/JsonOutput';
import { InfographicContainer } from '@/components/infographic';
import { ExtractionResult } from '@/lib/schema';

interface ApiResponse {
  success: boolean;
  data?: ExtractionResult;
  error?: string;
  duration?: number;
  retried?: boolean;
}

export default function Home() {
  const [memo, setMemo] = useState('');
  const [extractedData, setExtractedData] = useState<ExtractionResult | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [duration, setDuration] = useState<number | undefined>();
  const [retried, setRetried] = useState<boolean | undefined>();
  
  // Stage 2 State
  const [showInfographic, setShowInfographic] = useState(false);
  const [enhanceEnabled, setEnhanceEnabled] = useState(false);
  const [narrative, setNarrative] = useState<string | undefined>();
  const [headerImage, setHeaderImage] = useState<string | undefined>();
  const [isGeneratingNarrative, setIsGeneratingNarrative] = useState(false);
  const [isGeneratingImage, setIsGeneratingImage] = useState(false);
  const [copySuccess, setCopySuccess] = useState(false);
  
  const infographicRef = useRef<HTMLDivElement>(null);

  const handleExtract = async () => {
    if (memo.trim().length < 100) {
      setError('Please paste a complete investment memo (minimum 100 characters).');
      return;
    }

    setIsLoading(true);
    setError(null);
    setExtractedData(null);
    setDuration(undefined);
    setRetried(undefined);
    setShowInfographic(false);
    setNarrative(undefined);
    setHeaderImage(undefined);

    try {
      const response = await fetch('/api/extract', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ memo }),
      });

      const result: ApiResponse = await response.json();

      if (result.success && result.data) {
        setExtractedData(result.data);
        setDuration(result.duration);
        setRetried(result.retried);
      } else {
        setError(result.error || 'Unknown error occurred');
        setRetried(result.retried);
      }
    } catch (err) {
      setError(
        err instanceof Error 
          ? `Network error: ${err.message}` 
          : 'Failed to connect to the server'
      );
    } finally {
      setIsLoading(false);
    }
  };

  const handleClear = () => {
    setMemo('');
    setExtractedData(null);
    setError(null);
    setDuration(undefined);
    setRetried(undefined);
    setShowInfographic(false);
    setNarrative(undefined);
    setHeaderImage(undefined);
  };

  const handleGenerateInfographic = async () => {
    if (!extractedData) return;
    
    setShowInfographic(true);
    
    // If enhance is enabled, generate narrative
    if (enhanceEnabled) {
      setIsGeneratingNarrative(true);
      try {
        const response = await fetch('/api/enhance', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ data: extractedData }),
        });
        const result = await response.json();
        if (result.success && result.narrative) {
          setNarrative(result.narrative);
        }
      } catch (err) {
        console.error('Failed to generate narrative:', err);
      } finally {
        setIsGeneratingNarrative(false);
      }
    }

    // Scroll to infographic
    setTimeout(() => {
      infographicRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, 100);
  };

  const handleGenerateHeaderImage = async () => {
    if (!extractedData) return;
    
    setIsGeneratingImage(true);
    try {
      const response = await fetch('/api/generate-image', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          projectName: extractedData.metadata.projectName,
          industry: extractedData.metadata.industry,
          location: extractedData.metadata.location,
        }),
      });
      const result = await response.json();
      if (result.success && result.imageUrl) {
        setHeaderImage(result.imageUrl);
      }
    } catch (err) {
      console.error('Failed to generate header image:', err);
    } finally {
      setIsGeneratingImage(false);
    }
  };

  const handleCopyHtml = () => {
    setCopySuccess(true);
    setTimeout(() => setCopySuccess(false), 2000);
  };

  return (
    <main className="min-h-screen bg-[var(--background)]">
      {/* Header */}
      <header className="border-b border-[var(--border)] no-print">
        <div className="max-w-7xl mx-auto px-6 py-6">
          <div className="flex items-center gap-4">
            <div className="w-10 h-10 rounded-lg bg-gradient-to-br from-[var(--accent)] to-blue-700 flex items-center justify-center">
              <svg
                className="w-6 h-6 text-white"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"
                />
              </svg>
            </div>
            <div>
              <h1 className="text-2xl font-bold text-[var(--foreground)] tracking-tight">
                The Olsenator
              </h1>
              <p className="text-sm text-[var(--muted)]">
                Extraction & Visualization Engine
              </p>
            </div>
          </div>
        </div>
      </header>

      {/* Main Content */}
      <div className="max-w-7xl mx-auto px-6 py-8 no-print">
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
          {/* Left Column - Input */}
          <div className="space-y-4">
            <MemoInput
              value={memo}
              onChange={setMemo}
              disabled={isLoading}
            />
            
            <div className="flex gap-3">
              <button
                onClick={handleExtract}
                disabled={isLoading || memo.trim().length < 100}
                className="flex-1 px-6 py-3 bg-[var(--accent)] hover:bg-[var(--accent-hover)]
                           text-white font-semibold rounded-lg
                           disabled:opacity-50 disabled:cursor-not-allowed
                           transition-colors duration-200
                           flex items-center justify-center gap-2"
              >
                {isLoading ? (
                  <>
                    <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                    Extracting...
                  </>
                ) : (
                  <>
                    <svg
                      className="w-5 h-5"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"
                      />
                    </svg>
                    Extract Data
                  </>
                )}
              </button>
              
              <button
                onClick={handleClear}
                disabled={isLoading || (!memo && !extractedData && !error)}
                className="px-4 py-3 bg-[var(--surface)] border border-[var(--border)]
                           hover:bg-[var(--surface-hover)] text-[var(--foreground)]
                           font-medium rounded-lg
                           disabled:opacity-50 disabled:cursor-not-allowed
                           transition-colors duration-200"
              >
                Clear
              </button>
            </div>
          </div>

          {/* Right Column - Output */}
          <div className="space-y-4">
            <JsonOutput
              data={extractedData}
              error={error}
              isLoading={isLoading}
              duration={duration}
              retried={retried}
            />
            
            {/* Generate Infographic Button */}
            {extractedData && !showInfographic && (
              <div className="space-y-3">
                {/* Enhance Toggle */}
                <div className="flex items-center justify-between p-4 bg-[var(--surface)] border border-[var(--border)] rounded-lg">
                  <div className="flex items-center gap-3">
                    <svg className="w-5 h-5 text-[var(--muted)]" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
                    </svg>
                    <div>
                      <span className="text-sm font-medium text-[var(--foreground)]">Enhance with AI</span>
                      <p className="text-xs text-[var(--muted)]">Generate executive narrative summary</p>
                    </div>
                  </div>
                  <button
                    onClick={() => setEnhanceEnabled(!enhanceEnabled)}
                    className={`relative w-11 h-6 rounded-full transition-colors ${
                      enhanceEnabled ? 'bg-[var(--accent)]' : 'bg-[var(--border)]'
                    }`}
                  >
                    <span
                      className={`absolute top-1 left-1 w-4 h-4 rounded-full bg-white transition-transform ${
                        enhanceEnabled ? 'translate-x-5' : 'translate-x-0'
                      }`}
                    />
                  </button>
                </div>

                <button
                  onClick={handleGenerateInfographic}
                  className="w-full px-6 py-4 bg-gradient-to-r from-[#1e293b] to-[#334155]
                             hover:from-[#334155] hover:to-[#475569]
                             text-white font-semibold rounded-lg
                             transition-all duration-200
                             flex items-center justify-center gap-3"
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 17V7m0 10a2 2 0 01-2 2H5a2 2 0 01-2-2V7a2 2 0 012-2h2a2 2 0 012 2m0 10a2 2 0 002 2h2a2 2 0 002-2M9 7a2 2 0 012-2h2a2 2 0 012 2m0 10V7m0 10a2 2 0 002 2h2a2 2 0 002-2V7a2 2 0 00-2-2h-2a2 2 0 00-2 2" />
                  </svg>
                  Generate Infographic
                </button>
              </div>
            )}
          </div>
        </div>

        {/* Stage Disclaimer */}
        {!showInfographic && (
          <div className="mt-12 border-t border-[var(--border)] pt-6">
            <div className="flex items-start gap-3 text-sm text-[var(--muted)]">
              <svg
                className="w-5 h-5 flex-shrink-0 mt-0.5"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                />
              </svg>
              <div>
                <p className="font-medium text-[var(--foreground)]">Stage 2 — Rendering Engine</p>
                <p className="mt-1">
                  Extract data from your investment memo, then generate a visual infographic 
                  optimized for executive review and print-to-PDF export.
                </p>
              </div>
            </div>
          </div>
        )}
      </div>

      {/* Infographic Section */}
      {showInfographic && extractedData && (
        <div ref={infographicRef} className="border-t border-[var(--border)] bg-slate-100 no-print-bg">
          <div className="max-w-5xl mx-auto px-6 py-8">
            {/* Loading States */}
            {(isGeneratingNarrative || isGeneratingImage) && (
              <div className="mb-4 p-4 bg-blue-50 border border-blue-200 rounded-lg flex items-center gap-3 no-print">
                <div className="w-4 h-4 border-2 border-blue-300 border-t-blue-600 rounded-full animate-spin" />
                <span className="text-sm text-blue-700">
                  {isGeneratingNarrative && 'Generating executive narrative...'}
                  {isGeneratingImage && 'Generating header image...'}
                </span>
              </div>
            )}

            {/* Generate Header Image Button */}
            {!headerImage && !isGeneratingImage && (
              <div className="mb-4 no-print">
                <button
                  onClick={handleGenerateHeaderImage}
                  className="px-4 py-2 text-sm font-medium text-slate-600 bg-white border border-slate-300 rounded-lg hover:bg-slate-50 transition-colors flex items-center gap-2"
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                  </svg>
                  Generate Header Image (AI)
                </button>
              </div>
            )}

            {/* Copy Success Toast */}
            {copySuccess && (
              <div className="fixed bottom-4 right-4 px-4 py-2 bg-green-600 text-white rounded-lg shadow-lg z-50 no-print">
                HTML copied to clipboard!
              </div>
            )}

            {/* Infographic */}
            <InfographicContainer
              data={extractedData}
              narrative={narrative}
              headerImage={headerImage}
              onCopyHtml={handleCopyHtml}
            />
          </div>
        </div>
      )}

      {/* Footer */}
      <footer className="border-t border-[var(--border)] mt-auto no-print">
        <div className="max-w-7xl mx-auto px-6 py-4">
          <p className="text-xs text-[var(--muted)] text-center">
            Built for Innovera.ai — Transforming investment memos into visual insights
          </p>
        </div>
      </footer>
    </main>
  );
}
</file>

<file path="components/CopyButton.tsx">
'use client';

import { useState } from 'react';

interface CopyButtonProps {
  text: string;
  className?: string;
}

export function CopyButton({ text, className = '' }: CopyButtonProps) {
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error('Failed to copy:', err);
    }
  };

  return (
    <button
      onClick={handleCopy}
      className={`inline-flex items-center gap-2 px-3 py-1.5 text-sm font-medium
                  bg-[var(--surface)] border border-[var(--border)] rounded-md
                  text-[var(--foreground)] hover:bg-[var(--surface-hover)]
                  transition-colors duration-200 ${className}`}
      title="Copy to clipboard"
    >
      {copied ? (
        <>
          <svg
            className="w-4 h-4 text-green-500"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M5 13l4 4L19 7"
            />
          </svg>
          <span className="text-green-500">Copied!</span>
        </>
      ) : (
        <>
          <svg
            className="w-4 h-4"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
            />
          </svg>
          <span>Copy JSON</span>
        </>
      )}
    </button>
  );
}
</file>

<file path="components/JsonOutput.tsx">
'use client';

import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { oneDark } from 'react-syntax-highlighter/dist/esm/styles/prism';
import { CopyButton } from './CopyButton';

interface JsonOutputProps {
  data: object | null;
  error?: string | null;
  isLoading?: boolean;
  duration?: number;
  retried?: boolean;
}

export function JsonOutput({ data, error, isLoading, duration, retried }: JsonOutputProps) {
  const jsonString = data ? JSON.stringify(data, null, 2) : '';

  if (isLoading) {
    return (
      <div className="w-full h-[500px] bg-[var(--surface)] border border-[var(--border)] rounded-lg flex flex-col items-center justify-center gap-4">
        <div className="relative">
          <div className="w-12 h-12 border-4 border-[var(--border)] border-t-[var(--accent)] rounded-full animate-spin" />
        </div>
        <div className="text-center">
          <p className="text-[var(--foreground)] font-medium">Extracting memo data...</p>
          <p className="text-sm text-[var(--muted)] mt-1">This may take up to 30 seconds</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="w-full min-h-[200px] bg-[var(--surface)] border border-red-500/50 rounded-lg p-6">
        <div className="flex items-start gap-3">
          <svg
            className="w-6 h-6 text-red-500 flex-shrink-0 mt-0.5"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
            />
          </svg>
          <div>
            <h3 className="text-red-500 font-semibold">Extraction Failed</h3>
            <p className="text-[var(--muted)] mt-1">{error}</p>
            {retried && (
              <p className="text-xs text-[var(--muted)] mt-2">
                Note: A retry was attempted with a simplified prompt but also failed.
              </p>
            )}
          </div>
        </div>
      </div>
    );
  }

  if (!data) {
    return (
      <div className="w-full h-[500px] bg-[var(--surface)] border border-[var(--border)] border-dashed rounded-lg flex flex-col items-center justify-center gap-2">
        <svg
          className="w-12 h-12 text-[var(--muted)]"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={1.5}
            d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
          />
        </svg>
        <p className="text-[var(--muted)] text-center">
          Extracted JSON will appear here
        </p>
      </div>
    );
  }

  return (
    <div className="w-full">
      <div className="flex items-center justify-between mb-2">
        <div className="flex items-center gap-3">
          <span className="text-sm font-medium text-[var(--muted)]">
            Extracted JSON
          </span>
          {duration && (
            <span className="text-xs text-[var(--muted)] bg-[var(--surface)] px-2 py-0.5 rounded">
              {(duration / 1000).toFixed(1)}s
            </span>
          )}
          {retried && (
            <span className="text-xs text-yellow-500 bg-yellow-500/10 px-2 py-0.5 rounded">
              Retried
            </span>
          )}
        </div>
        <CopyButton text={jsonString} />
      </div>
      <div className="relative rounded-lg overflow-hidden border border-[var(--border)]">
        <SyntaxHighlighter
          language="json"
          style={oneDark}
          customStyle={{
            margin: 0,
            padding: '1rem',
            background: 'var(--surface)',
            fontSize: '0.8125rem',
            lineHeight: '1.5',
            maxHeight: '500px',
            overflow: 'auto',
          }}
          showLineNumbers
          lineNumberStyle={{
            minWidth: '2.5em',
            paddingRight: '1em',
            color: 'var(--muted)',
            userSelect: 'none',
          }}
        >
          {jsonString}
        </SyntaxHighlighter>
      </div>
    </div>
  );
}
</file>

<file path="components/MemoInput.tsx">
'use client';

interface MemoInputProps {
  value: string;
  onChange: (value: string) => void;
  disabled?: boolean;
}

export function MemoInput({ value, onChange, disabled }: MemoInputProps) {
  return (
    <div className="w-full">
      <label 
        htmlFor="memo-input" 
        className="block text-sm font-medium text-[var(--muted)] mb-2"
      >
        Investment Memo
      </label>
      <textarea
        id="memo-input"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        disabled={disabled}
        placeholder="Paste your investment memo here...

Expected format includes:
• Overview Table (project metadata)
• 'Tell it to me straight' section
• Strategic Fit analysis
• Highlights and key findings
• 'What You Would Have To Believe' assumptions
• Six-T Risk Analysis (Team, TAM, Technology, Traction, Terms, Trends)
• 'Should We Do It' and 'Can We Do It' assessments
• Chapter analyses (Team, Opportunity, Path to Success, Operations)"
        className="w-full h-[400px] px-4 py-3 bg-[var(--surface)] border border-[var(--border)] 
                   rounded-lg text-[var(--foreground)] placeholder-[var(--muted)]
                   focus:outline-none focus:ring-2 focus:ring-[var(--accent)] focus:border-transparent
                   resize-none font-mono text-sm leading-relaxed
                   disabled:opacity-50 disabled:cursor-not-allowed
                   transition-all duration-200"
        spellCheck={false}
      />
      <div className="mt-2 flex justify-between text-xs text-[var(--muted)]">
        <span>
          {value.length.toLocaleString()} characters
        </span>
        <span>
          Minimum 100 characters required
        </span>
      </div>
    </div>
  );
}
</file>

<file path="lib/openrouter.ts">
import { ExtractionResult, validateExtractionResult } from './schema';
import { EXTRACTION_SYSTEM_PROMPT, SIMPLIFIED_EXTRACTION_PROMPT, createUserPrompt } from './prompts';

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
const MODEL = 'google/gemini-2.5-pro-preview';

interface OpenRouterMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

interface OpenRouterResponse {
  id: string;
  choices: {
    message: {
      content: string;
    };
    finish_reason: string;
  }[];
  error?: {
    message: string;
    code: string;
  };
}

export interface ExtractionResponse {
  success: boolean;
  data?: ExtractionResult;
  error?: string;
  retried?: boolean;
}

/**
 * Extracts JSON from a response that might contain markdown code blocks
 */
function extractJsonFromResponse(content: string): string {
  // Try to extract JSON from markdown code blocks
  const jsonBlockMatch = content.match(/```(?:json)?\s*([\s\S]*?)```/);
  if (jsonBlockMatch) {
    return jsonBlockMatch[1].trim();
  }
  
  // Try to find raw JSON object
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (jsonMatch) {
    return jsonMatch[0];
  }
  
  return content.trim();
}

/**
 * Calls OpenRouter API with the given messages
 */
async function callOpenRouter(
  messages: OpenRouterMessage[],
  apiKey: string
): Promise<{ content: string; error?: string }> {
  try {
    const response = await fetch(OPENROUTER_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`,
        'HTTP-Referer': 'https://olsenator.vercel.app',
        'X-Title': 'The Olsenator',
      },
      body: JSON.stringify({
        model: MODEL,
        messages,
        temperature: 0.1, // Low temperature for consistent extraction
        max_tokens: 8192,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('OpenRouter API error:', response.status, errorText);
      return {
        content: '',
        error: `API request failed with status ${response.status}: ${errorText}`,
      };
    }

    const data: OpenRouterResponse = await response.json();

    if (data.error) {
      return {
        content: '',
        error: `OpenRouter error: ${data.error.message}`,
      };
    }

    if (!data.choices || data.choices.length === 0) {
      return {
        content: '',
        error: 'No response generated by the model',
      };
    }

    return {
      content: data.choices[0].message.content,
    };
  } catch (error) {
    console.error('OpenRouter request failed:', error);
    return {
      content: '',
      error: error instanceof Error ? error.message : 'Unknown error occurred',
    };
  }
}

/**
 * Attempts to parse and validate the extraction result
 */
function parseExtractionResult(content: string): { data?: ExtractionResult; error?: string } {
  try {
    const jsonContent = extractJsonFromResponse(content);
    const parsed = JSON.parse(jsonContent);
    
    if (!validateExtractionResult(parsed)) {
      return { error: 'Response does not match expected schema structure' };
    }
    
    return { data: parsed as ExtractionResult };
  } catch (error) {
    console.error('JSON parse error:', error);
    return { 
      error: error instanceof Error ? `Invalid JSON: ${error.message}` : 'Failed to parse JSON' 
    };
  }
}

/**
 * Main extraction function - extracts structured data from an investment memo
 * 
 * @param memoContent - The raw investment memo text
 * @param apiKey - OpenRouter API key
 * @returns ExtractionResponse with success status and data or error
 */
export async function extractMemoData(
  memoContent: string,
  apiKey: string
): Promise<ExtractionResponse> {
  if (!memoContent.trim()) {
    return {
      success: false,
      error: 'Memo content cannot be empty',
    };
  }

  if (!apiKey) {
    return {
      success: false,
      error: 'OpenRouter API key is not configured',
    };
  }

  // First attempt with full prompt
  const messages: OpenRouterMessage[] = [
    { role: 'system', content: EXTRACTION_SYSTEM_PROMPT },
    { role: 'user', content: createUserPrompt(memoContent) },
  ];

  console.log('Attempting extraction with full prompt...');
  const firstResponse = await callOpenRouter(messages, apiKey);

  if (firstResponse.error) {
    return {
      success: false,
      error: firstResponse.error,
    };
  }

  // Try to parse first response
  const firstParse = parseExtractionResult(firstResponse.content);
  if (firstParse.data) {
    return {
      success: true,
      data: firstParse.data,
    };
  }

  // Retry with simplified prompt
  console.log('First attempt failed, retrying with simplified prompt...');
  console.log('First attempt error:', firstParse.error);

  const retryMessages: OpenRouterMessage[] = [
    { role: 'system', content: SIMPLIFIED_EXTRACTION_PROMPT },
    { role: 'user', content: createUserPrompt(memoContent) },
  ];

  const retryResponse = await callOpenRouter(retryMessages, apiKey);

  if (retryResponse.error) {
    return {
      success: false,
      error: `Retry failed: ${retryResponse.error}`,
      retried: true,
    };
  }

  const retryParse = parseExtractionResult(retryResponse.content);
  if (retryParse.data) {
    return {
      success: true,
      data: retryParse.data,
      retried: true,
    };
  }

  return {
    success: false,
    error: `Failed to extract valid JSON after retry. Last error: ${retryParse.error}`,
    retried: true,
  };
}
</file>

<file path="lib/prompts.ts">
import { EXTRACTION_SCHEMA_JSON } from './schema';

/**
 * System prompt for Gemini 2.5 Pro to extract structured data from investment memos
 */
export const EXTRACTION_SYSTEM_PROMPT = `You are a specialized structured data extractor for investment memos. Your role is to parse investment memo documents and extract key information into a precise JSON format.

## Your Task
Analyze the provided investment memo and extract all relevant information into the JSON schema specified below. You must:

1. **Output valid JSON only** - No markdown, no explanations, just the JSON object
2. **Extract and summarize** - Condense verbose sections into concise summaries rather than copying verbatim
3. **Infer ratings and confidence** - When ratings (red/yellow/green) or confidence levels aren't explicitly stated, infer them from contextual language:
   - Strong positive language → green / High confidence
   - Mixed or cautionary language → yellow / Medium confidence  
   - Negative or warning language → red / Low confidence
4. **Handle missing sections gracefully** - Use null for missing values, empty arrays for missing lists. NEVER hallucinate or fabricate information
5. **Self-report confidence** - Set the top-level "confidence" field (0-100) based on:
   - How well the input memo matched expected structure
   - How complete the information was
   - How confident you are in your extractions

## Expected Memo Structure
Investment memos typically contain:
- Overview Table (project metadata)
- "Tell it to me straight" section (blunt assessment)
- Strategic Fit analysis
- Highlights (key findings with metrics)
- "What You Would Have To Believe" (critical assumptions)
- Hypotheses/Next Steps
- Six-T Risk Analysis (Team, TAM, Technology, Traction, Terms, Trends)
- "Should We Do It" and "Can We Do It" assessments
- Detailed chapters: Team, Opportunity Validation, Path to Success, Operations

## Output Schema
Your response must be a valid JSON object matching this exact structure:

${EXTRACTION_SCHEMA_JSON}

## Field Guidelines

### metadata
- projectName: The name of the project/initiative being evaluated
- stage: Investment stage (e.g., "Seed", "Series A", "Proof of Concept", "Pilot")
- industry: Primary industry or sector
- location: Geographic location if mentioned, null otherwise
- decision: Overall recommendation - must be exactly "Proceed", "Do Not Proceed", or "Conditional"
- recommendation: One-sentence summary of the recommendation

### executiveSummary
- verdict: The core "tell it to me straight" assessment in 1-2 sentences
- coreReasoning: Array of 3-5 key points supporting the verdict

### strategicFit
- assessment: Summary of how well the project aligns with strategic goals
- confidenceLevel: "High", "Medium", or "Low"

### highlights
Extract 4-8 key metrics or findings. For each:
- metric: What is being measured (e.g., "Market Size", "IRR", "Customer Acquisition Cost")
- value: The specific number or result (e.g., "$50B", "127%", "18 months")
- context: Brief explanation of significance

### criticalAssumptions
Extract assumptions from "What You Would Have To Believe" section:
- assumption: The belief or assumption stated
- status: "validated" (evidence supports it), "pending" (untested), or "at-risk" (evidence contradicts)

### sixTRisks
For each of the six T's:
- rating: "red" (high risk), "yellow" (moderate risk), or "green" (low risk)
- summary: One sentence explaining the rating

### shouldWeDoIt / canWeDoIt
- verdict: One-sentence answer to the question
- confidenceLevel: "High", "Medium", or "Low"
- supportingFactors: Array of 3-5 bullet points

### nextSteps
Extract recommended actions:
- action: What should be done
- rationale: Why this action matters
- successGate: How to know if it succeeded

### chapters
For each chapter, extract:
- Summary assessments and key findings
- dataPoints: 2-3 specific extractable data points suitable for visualization

Remember: Output ONLY the JSON object. No other text.`;

/**
 * Simplified retry prompt for when initial extraction fails
 */
export const SIMPLIFIED_EXTRACTION_PROMPT = `Extract key information from this investment memo into JSON format.

Output a JSON object with these fields:
- confidence (number 0-100)
- metadata (projectName, stage, industry, location, decision, recommendation)
- executiveSummary (verdict, coreReasoning array)
- strategicFit (assessment, confidenceLevel)
- highlights (array of metric/value/context objects)
- criticalAssumptions (array of assumption/status objects)
- sixTRisks (team/tam/technology/traction/terms/trends, each with rating and summary)
- shouldWeDoIt (verdict, confidenceLevel, supportingFactors)
- canWeDoIt (verdict, confidenceLevel, supportingFactors)
- nextSteps (array of action/rationale/successGate objects)
- chapters (team/opportunityValidation/pathToSuccess/operations with relevant fields)

Use null for missing values. Ratings are "red"/"yellow"/"green". Confidence levels are "High"/"Medium"/"Low".

Output ONLY valid JSON, no other text.`;

/**
 * Creates the user prompt with the memo content
 */
export function createUserPrompt(memoContent: string): string {
  return `Please extract structured data from the following investment memo:

---
${memoContent}
---

Remember: Output ONLY the JSON object matching the schema. No explanations or markdown.`;
}
</file>

<file path="lib/schema.ts">
/**
 * Extraction Schema for The Olsenator
 * 
 * This schema defines the structure of JSON data extracted from investment memos.
 * It is designed to be visualization-ready for Stage 2's rendering engine.
 */

export type RiskRating = "red" | "yellow" | "green";
export type ConfidenceLevel = "High" | "Medium" | "Low";
export type Decision = "Proceed" | "Do Not Proceed" | "Conditional";
export type AssumptionStatus = "validated" | "pending" | "at-risk";

export interface RiskAssessment {
  rating: RiskRating;
  summary: string;
}

export interface Highlight {
  metric: string;
  value: string;
  context: string;
}

export interface CriticalAssumption {
  assumption: string;
  status: AssumptionStatus;
}

export interface NextStep {
  action: string;
  rationale: string;
  successGate: string;
}

export interface ProjectMetadata {
  projectName: string;
  stage: string;
  industry: string;
  location: string | null;
  decision: Decision;
  recommendation: string;
}

export interface ExecutiveSummary {
  verdict: string;
  coreReasoning: string[];
}

export interface StrategicFit {
  assessment: string;
  confidenceLevel: ConfidenceLevel;
}

export interface SixTRisks {
  team: RiskAssessment;
  tam: RiskAssessment;
  technology: RiskAssessment;
  traction: RiskAssessment;
  terms: RiskAssessment;
  trends: RiskAssessment;
}

export interface Verdict {
  verdict: string;
  confidenceLevel: ConfidenceLevel;
  supportingFactors: string[];
}

export interface TeamChapter {
  capabilityAssessment: string;
  identifiedGaps: string[];
  dataPoints: string[];
}

export interface OpportunityValidationChapter {
  problemStatement: string;
  marketSize: string;
  competitivePositioning: string;
  dataPoints: string[];
}

export interface PathToSuccessChapter {
  productRequirements: string;
  goToMarket: string;
  revenueModel: string;
  dataPoints: string[];
}

export interface OperationsChapter {
  irr: string | null;
  paybackPeriod: string | null;
  margins: string | null;
  operationalRisks: string[];
  dataPoints: string[];
}

export interface Chapters {
  team: TeamChapter;
  opportunityValidation: OpportunityValidationChapter;
  pathToSuccess: PathToSuccessChapter;
  operations: OperationsChapter;
}

export interface ExtractionResult {
  /** Self-reported confidence score (0-100) based on input quality */
  confidence: number;
  
  /** Project metadata from the Overview Table */
  metadata: ProjectMetadata;
  
  /** Executive summary from "Tell it to me straight" section */
  executiveSummary: ExecutiveSummary;
  
  /** Strategic fit assessment with confidence level */
  strategicFit: StrategicFit;
  
  /** Key highlights with metrics and context */
  highlights: Highlight[];
  
  /** Critical assumptions with validation status */
  criticalAssumptions: CriticalAssumption[];
  
  /** Six-T Risk Analysis ratings */
  sixTRisks: SixTRisks;
  
  /** "Should We Do It" verdict and supporting factors */
  shouldWeDoIt: Verdict;
  
  /** "Can We Do It" verdict and supporting factors */
  canWeDoIt: Verdict;
  
  /** Recommended next steps with actions and success gates */
  nextSteps: NextStep[];
  
  /** Detailed chapter-level extractions */
  chapters: Chapters;
}

/**
 * JSON Schema representation for embedding in prompts
 * This is used to instruct the LLM on exact output structure
 */
export const EXTRACTION_SCHEMA_JSON = `{
  "confidence": number (0-100),
  "metadata": {
    "projectName": string,
    "stage": string,
    "industry": string,
    "location": string | null,
    "decision": "Proceed" | "Do Not Proceed" | "Conditional",
    "recommendation": string
  },
  "executiveSummary": {
    "verdict": string,
    "coreReasoning": string[]
  },
  "strategicFit": {
    "assessment": string,
    "confidenceLevel": "High" | "Medium" | "Low"
  },
  "highlights": [
    {
      "metric": string,
      "value": string,
      "context": string
    }
  ],
  "criticalAssumptions": [
    {
      "assumption": string,
      "status": "validated" | "pending" | "at-risk"
    }
  ],
  "sixTRisks": {
    "team": { "rating": "red" | "yellow" | "green", "summary": string },
    "tam": { "rating": "red" | "yellow" | "green", "summary": string },
    "technology": { "rating": "red" | "yellow" | "green", "summary": string },
    "traction": { "rating": "red" | "yellow" | "green", "summary": string },
    "terms": { "rating": "red" | "yellow" | "green", "summary": string },
    "trends": { "rating": "red" | "yellow" | "green", "summary": string }
  },
  "shouldWeDoIt": {
    "verdict": string,
    "confidenceLevel": "High" | "Medium" | "Low",
    "supportingFactors": string[]
  },
  "canWeDoIt": {
    "verdict": string,
    "confidenceLevel": "High" | "Medium" | "Low",
    "supportingFactors": string[]
  },
  "nextSteps": [
    {
      "action": string,
      "rationale": string,
      "successGate": string
    }
  ],
  "chapters": {
    "team": {
      "capabilityAssessment": string,
      "identifiedGaps": string[],
      "dataPoints": string[]
    },
    "opportunityValidation": {
      "problemStatement": string,
      "marketSize": string,
      "competitivePositioning": string,
      "dataPoints": string[]
    },
    "pathToSuccess": {
      "productRequirements": string,
      "goToMarket": string,
      "revenueModel": string,
      "dataPoints": string[]
    },
    "operations": {
      "irr": string | null,
      "paybackPeriod": string | null,
      "margins": string | null,
      "operationalRisks": string[],
      "dataPoints": string[]
    }
  }
}`;

/**
 * Validates that an object matches the ExtractionResult structure
 * Returns true if valid, false otherwise
 */
export function validateExtractionResult(data: unknown): data is ExtractionResult {
  if (!data || typeof data !== 'object') return false;
  
  const result = data as Record<string, unknown>;
  
  // Check top-level required fields
  if (typeof result.confidence !== 'number') return false;
  if (!result.metadata || typeof result.metadata !== 'object') return false;
  if (!result.executiveSummary || typeof result.executiveSummary !== 'object') return false;
  if (!result.strategicFit || typeof result.strategicFit !== 'object') return false;
  if (!Array.isArray(result.highlights)) return false;
  if (!Array.isArray(result.criticalAssumptions)) return false;
  if (!result.sixTRisks || typeof result.sixTRisks !== 'object') return false;
  if (!result.shouldWeDoIt || typeof result.shouldWeDoIt !== 'object') return false;
  if (!result.canWeDoIt || typeof result.canWeDoIt !== 'object') return false;
  if (!Array.isArray(result.nextSteps)) return false;
  if (!result.chapters || typeof result.chapters !== 'object') return false;
  
  // Validate Six-T structure
  const sixT = result.sixTRisks as Record<string, unknown>;
  const requiredRisks = ['team', 'tam', 'technology', 'traction', 'terms', 'trends'];
  for (const risk of requiredRisks) {
    if (!sixT[risk] || typeof sixT[risk] !== 'object') return false;
    const riskObj = sixT[risk] as Record<string, unknown>;
    if (!['red', 'yellow', 'green'].includes(riskObj.rating as string)) return false;
    if (typeof riskObj.summary !== 'string') return false;
  }
  
  return true;
}
</file>

<file path="next.config.mjs">
/** @type {import('next').NextConfig} */
const nextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="package.json">
{
  "name": "olsenator",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "^14.2.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-syntax-highlighter": "^15.5.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@types/react-syntax-highlighter": "^15.5.11",
    "autoprefixer": "^10.4.0",
    "eslint": "^8.0.0",
    "eslint-config-next": "^14.2.0",
    "postcss": "^8.4.0",
    "tailwindcss": "^3.4.0",
    "typescript": "^5.0.0"
  }
}
</file>

<file path="postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

export default config;
</file>

<file path="README.md">
# The Olsenator — Extraction Engine

Transform investment memos into structured JSON data for visualization.

## Overview

The Olsenator is an infographic generator that transforms structured investment memos into visually rich, branded HTML infographics. This repository contains **Stage 1: The Extraction Engine** — a Next.js application that parses investment memos and extracts structured data into a fixed JSON schema.

**Stage 2** (future build) will be the Rendering Engine that consumes this JSON and produces deterministic, templated HTML infographics.

## Features

- **AI-Powered Extraction**: Uses Gemini 2.5 Pro via OpenRouter to intelligently parse investment memos
- **Comprehensive Schema**: Captures all memo elements including metadata, Six-T risks, highlights, and chapter analyses
- **Robust Error Handling**: Automatic retry with simplified prompts when extraction fails
- **Minimal UI**: Clean, dark interface for pasting memos and viewing extracted JSON
- **Copy to Clipboard**: Easy export of extracted JSON for downstream use

## Getting Started

### Prerequisites

- Node.js 18+ 
- An [OpenRouter](https://openrouter.ai/) API key

### Installation

1. Clone the repository:
   ```bash
   git clone <repository-url>
   cd olsenator
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Create a `.env.local` file with your OpenRouter API key:
   ```
   OPENROUTER_API_KEY=your_openrouter_api_key_here
   ```

4. Start the development server:
   ```bash
   npm run dev
   ```

5. Open [http://localhost:3000](http://localhost:3000) in your browser.

## Usage

1. Paste your investment memo text into the input area
2. Click "Extract Data"
3. Wait for the AI to process (typically 10-30 seconds)
4. View the structured JSON output
5. Click "Copy JSON" to export the data

## JSON Schema

The extraction produces a comprehensive JSON object with the following structure:

```typescript
{
  confidence: number;           // 0-100 self-reported extraction confidence
  metadata: {
    projectName, stage, industry, location, decision, recommendation
  };
  executiveSummary: {
    verdict, coreReasoning[]
  };
  strategicFit: {
    assessment, confidenceLevel
  };
  highlights: Array<{ metric, value, context }>;
  criticalAssumptions: Array<{ assumption, status }>;
  sixTRisks: {
    team, tam, technology, traction, terms, trends
    // Each with { rating: "red"|"yellow"|"green", summary }
  };
  shouldWeDoIt: { verdict, confidenceLevel, supportingFactors[] };
  canWeDoIt: { verdict, confidenceLevel, supportingFactors[] };
  nextSteps: Array<{ action, rationale, successGate }>;
  chapters: {
    team: { capabilityAssessment, identifiedGaps[], dataPoints[] },
    opportunityValidation: { problemStatement, marketSize, competitivePositioning, dataPoints[] },
    pathToSuccess: { productRequirements, goToMarket, revenueModel, dataPoints[] },
    operations: { irr, paybackPeriod, margins, operationalRisks[], dataPoints[] }
  };
}
```

## Tech Stack

- **Framework**: Next.js 14 with App Router
- **Styling**: Tailwind CSS
- **LLM**: Gemini 2.5 Pro via OpenRouter
- **Syntax Highlighting**: react-syntax-highlighter

## Deployment

This application is configured for deployment on Vercel:

```bash
npm run build
```

Make sure to set `OPENROUTER_API_KEY` in your Vercel project environment variables.

## Project Structure

```
├── app/
│   ├── layout.tsx        # Root layout
│   ├── page.tsx          # Main extraction UI
│   ├── globals.css       # Tailwind imports and CSS variables
│   └── api/extract/
│       └── route.ts      # OpenRouter API integration
├── lib/
│   ├── schema.ts         # TypeScript interfaces and validation
│   ├── prompts.ts        # Gemini system prompts
│   └── openrouter.ts     # OpenRouter client wrapper
├── components/
│   ├── MemoInput.tsx     # Text input component
│   ├── JsonOutput.tsx    # Syntax-highlighted JSON display
│   └── CopyButton.tsx    # Copy to clipboard button
└── package.json
```

## License

Built for Innovera.ai

#   o l s e n a t o r 
 
 
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";

const config: Config = {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      fontFamily: {
        sans: ["var(--font-geist-sans)"],
        mono: ["var(--font-geist-mono)"],
      },
    },
  },
  plugins: [],
};

export default config;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

</files>
