This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.local.example
.gitignore
app/api/extract/route.ts
app/globals.css
app/layout.tsx
app/page.tsx
components/CopyButton.tsx
components/JsonOutput.tsx
components/MemoInput.tsx
lib/openrouter.ts
lib/prompts.ts
lib/schema.ts
next.config.mjs
package.json
postcss.config.mjs
README.md
tailwind.config.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.local.example">
# OpenRouter API Key for Gemini 2.5 Pro access
OPENROUTER_API_KEY=your_openrouter_api_key_here
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="app/api/extract/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { extractMemoData } from '@/lib/openrouter';

export const maxDuration = 60; // Allow up to 60 seconds for extraction

interface ExtractRequest {
  memo: string;
}

export async function POST(request: NextRequest) {
  try {
    const body: ExtractRequest = await request.json();

    if (!body.memo || typeof body.memo !== 'string') {
      return NextResponse.json(
        { success: false, error: 'Missing or invalid memo content' },
        { status: 400 }
      );
    }

    if (body.memo.trim().length < 100) {
      return NextResponse.json(
        { success: false, error: 'Memo content is too short. Please paste the full investment memo.' },
        { status: 400 }
      );
    }

    const apiKey = process.env.OPENROUTER_API_KEY;

    if (!apiKey) {
      console.error('OPENROUTER_API_KEY is not configured');
      return NextResponse.json(
        { success: false, error: 'Server configuration error: API key not configured' },
        { status: 500 }
      );
    }

    console.log(`Processing memo extraction (${body.memo.length} characters)...`);
    const startTime = Date.now();

    const result = await extractMemoData(body.memo, apiKey);

    const duration = Date.now() - startTime;
    console.log(`Extraction completed in ${duration}ms, success: ${result.success}`);

    if (!result.success) {
      console.error('Extraction failed:', result.error);
      return NextResponse.json(
        { 
          success: false, 
          error: result.error,
          retried: result.retried 
        },
        { status: 422 }
      );
    }

    return NextResponse.json({
      success: true,
      data: result.data,
      retried: result.retried,
      duration,
    });
  } catch (error) {
    console.error('Unexpected error in extract route:', error);
    return NextResponse.json(
      { 
        success: false, 
        error: error instanceof Error ? error.message : 'An unexpected error occurred' 
      },
      { status: 500 }
    );
  }
}
</file>

<file path="app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #0a0a0a;
  --foreground: #ededed;
  --accent: #3b82f6;
  --accent-hover: #2563eb;
  --surface: #141414;
  --surface-hover: #1a1a1a;
  --border: #2a2a2a;
  --muted: #737373;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: var(--font-geist-sans), system-ui, sans-serif;
}

/* Custom scrollbar for dark theme */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--surface);
}

::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--muted);
}

/* Textarea styling */
textarea {
  scrollbar-width: thin;
  scrollbar-color: var(--border) var(--surface);
}
</file>

<file path="app/layout.tsx">
import type { Metadata } from "next";
import { Inter, JetBrains_Mono } from "next/font/google";
import "./globals.css";

const inter = Inter({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const jetbrainsMono = JetBrains_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "The Olsenator — Extraction Engine",
  description: "Transform investment memos into structured JSON data",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${inter.variable} ${jetbrainsMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
</file>

<file path="app/page.tsx">
'use client';

import { useState } from 'react';
import { MemoInput } from '@/components/MemoInput';
import { JsonOutput } from '@/components/JsonOutput';
import { ExtractionResult } from '@/lib/schema';

interface ApiResponse {
  success: boolean;
  data?: ExtractionResult;
  error?: string;
  duration?: number;
  retried?: boolean;
}

export default function Home() {
  const [memo, setMemo] = useState('');
  const [extractedData, setExtractedData] = useState<ExtractionResult | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [duration, setDuration] = useState<number | undefined>();
  const [retried, setRetried] = useState<boolean | undefined>();

  const handleExtract = async () => {
    if (memo.trim().length < 100) {
      setError('Please paste a complete investment memo (minimum 100 characters).');
      return;
    }

    setIsLoading(true);
    setError(null);
    setExtractedData(null);
    setDuration(undefined);
    setRetried(undefined);

    try {
      const response = await fetch('/api/extract', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ memo }),
      });

      const result: ApiResponse = await response.json();

      if (result.success && result.data) {
        setExtractedData(result.data);
        setDuration(result.duration);
        setRetried(result.retried);
      } else {
        setError(result.error || 'Unknown error occurred');
        setRetried(result.retried);
      }
    } catch (err) {
      setError(
        err instanceof Error 
          ? `Network error: ${err.message}` 
          : 'Failed to connect to the server'
      );
    } finally {
      setIsLoading(false);
    }
  };

  const handleClear = () => {
    setMemo('');
    setExtractedData(null);
    setError(null);
    setDuration(undefined);
    setRetried(undefined);
  };

  return (
    <main className="min-h-screen bg-[var(--background)]">
      {/* Header */}
      <header className="border-b border-[var(--border)]">
        <div className="max-w-7xl mx-auto px-6 py-6">
          <div className="flex items-center gap-4">
            <div className="w-10 h-10 rounded-lg bg-gradient-to-br from-[var(--accent)] to-blue-700 flex items-center justify-center">
              <svg
                className="w-6 h-6 text-white"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"
                />
              </svg>
            </div>
            <div>
              <h1 className="text-2xl font-bold text-[var(--foreground)] tracking-tight">
                The Olsenator
              </h1>
              <p className="text-sm text-[var(--muted)]">
                Extraction Engine
              </p>
            </div>
          </div>
        </div>
      </header>

      {/* Main Content */}
      <div className="max-w-7xl mx-auto px-6 py-8">
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
          {/* Left Column - Input */}
          <div className="space-y-4">
            <MemoInput
              value={memo}
              onChange={setMemo}
              disabled={isLoading}
            />
            
            <div className="flex gap-3">
              <button
                onClick={handleExtract}
                disabled={isLoading || memo.trim().length < 100}
                className="flex-1 px-6 py-3 bg-[var(--accent)] hover:bg-[var(--accent-hover)]
                           text-white font-semibold rounded-lg
                           disabled:opacity-50 disabled:cursor-not-allowed
                           transition-colors duration-200
                           flex items-center justify-center gap-2"
              >
                {isLoading ? (
                  <>
                    <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />
                    Extracting...
                  </>
                ) : (
                  <>
                    <svg
                      className="w-5 h-5"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"
                      />
                    </svg>
                    Extract Data
                  </>
                )}
              </button>
              
              <button
                onClick={handleClear}
                disabled={isLoading || (!memo && !extractedData && !error)}
                className="px-4 py-3 bg-[var(--surface)] border border-[var(--border)]
                           hover:bg-[var(--surface-hover)] text-[var(--foreground)]
                           font-medium rounded-lg
                           disabled:opacity-50 disabled:cursor-not-allowed
                           transition-colors duration-200"
              >
                Clear
              </button>
            </div>
          </div>

          {/* Right Column - Output */}
          <div>
            <JsonOutput
              data={extractedData}
              error={error}
              isLoading={isLoading}
              duration={duration}
              retried={retried}
            />
          </div>
        </div>

        {/* Stage Disclaimer */}
        <div className="mt-12 border-t border-[var(--border)] pt-6">
          <div className="flex items-start gap-3 text-sm text-[var(--muted)]">
            <svg
              className="w-5 h-5 flex-shrink-0 mt-0.5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
              />
            </svg>
            <div>
              <p className="font-medium text-[var(--foreground)]">Stage 1 — Extraction Engine</p>
              <p className="mt-1">
                This is the data extraction phase of The Olsenator. The JSON output produced here 
                will be consumed by Stage 2&apos;s rendering engine to generate visual infographics. 
                Copy the extracted JSON for use in downstream visualization workflows.
              </p>
            </div>
          </div>
        </div>
      </div>

      {/* Footer */}
      <footer className="border-t border-[var(--border)] mt-auto">
        <div className="max-w-7xl mx-auto px-6 py-4">
          <p className="text-xs text-[var(--muted)] text-center">
            Built for Innovera.ai — Transforming investment memos into structured data
          </p>
        </div>
      </footer>
    </main>
  );
}
</file>

<file path="components/CopyButton.tsx">
'use client';

import { useState } from 'react';

interface CopyButtonProps {
  text: string;
  className?: string;
}

export function CopyButton({ text, className = '' }: CopyButtonProps) {
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error('Failed to copy:', err);
    }
  };

  return (
    <button
      onClick={handleCopy}
      className={`inline-flex items-center gap-2 px-3 py-1.5 text-sm font-medium
                  bg-[var(--surface)] border border-[var(--border)] rounded-md
                  text-[var(--foreground)] hover:bg-[var(--surface-hover)]
                  transition-colors duration-200 ${className}`}
      title="Copy to clipboard"
    >
      {copied ? (
        <>
          <svg
            className="w-4 h-4 text-green-500"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M5 13l4 4L19 7"
            />
          </svg>
          <span className="text-green-500">Copied!</span>
        </>
      ) : (
        <>
          <svg
            className="w-4 h-4"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
            />
          </svg>
          <span>Copy JSON</span>
        </>
      )}
    </button>
  );
}
</file>

<file path="components/JsonOutput.tsx">
'use client';

import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { oneDark } from 'react-syntax-highlighter/dist/esm/styles/prism';
import { CopyButton } from './CopyButton';

interface JsonOutputProps {
  data: object | null;
  error?: string | null;
  isLoading?: boolean;
  duration?: number;
  retried?: boolean;
}

export function JsonOutput({ data, error, isLoading, duration, retried }: JsonOutputProps) {
  const jsonString = data ? JSON.stringify(data, null, 2) : '';

  if (isLoading) {
    return (
      <div className="w-full h-[500px] bg-[var(--surface)] border border-[var(--border)] rounded-lg flex flex-col items-center justify-center gap-4">
        <div className="relative">
          <div className="w-12 h-12 border-4 border-[var(--border)] border-t-[var(--accent)] rounded-full animate-spin" />
        </div>
        <div className="text-center">
          <p className="text-[var(--foreground)] font-medium">Extracting memo data...</p>
          <p className="text-sm text-[var(--muted)] mt-1">This may take up to 30 seconds</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="w-full min-h-[200px] bg-[var(--surface)] border border-red-500/50 rounded-lg p-6">
        <div className="flex items-start gap-3">
          <svg
            className="w-6 h-6 text-red-500 flex-shrink-0 mt-0.5"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
            />
          </svg>
          <div>
            <h3 className="text-red-500 font-semibold">Extraction Failed</h3>
            <p className="text-[var(--muted)] mt-1">{error}</p>
            {retried && (
              <p className="text-xs text-[var(--muted)] mt-2">
                Note: A retry was attempted with a simplified prompt but also failed.
              </p>
            )}
          </div>
        </div>
      </div>
    );
  }

  if (!data) {
    return (
      <div className="w-full h-[500px] bg-[var(--surface)] border border-[var(--border)] border-dashed rounded-lg flex flex-col items-center justify-center gap-2">
        <svg
          className="w-12 h-12 text-[var(--muted)]"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={1.5}
            d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
          />
        </svg>
        <p className="text-[var(--muted)] text-center">
          Extracted JSON will appear here
        </p>
      </div>
    );
  }

  return (
    <div className="w-full">
      <div className="flex items-center justify-between mb-2">
        <div className="flex items-center gap-3">
          <span className="text-sm font-medium text-[var(--muted)]">
            Extracted JSON
          </span>
          {duration && (
            <span className="text-xs text-[var(--muted)] bg-[var(--surface)] px-2 py-0.5 rounded">
              {(duration / 1000).toFixed(1)}s
            </span>
          )}
          {retried && (
            <span className="text-xs text-yellow-500 bg-yellow-500/10 px-2 py-0.5 rounded">
              Retried
            </span>
          )}
        </div>
        <CopyButton text={jsonString} />
      </div>
      <div className="relative rounded-lg overflow-hidden border border-[var(--border)]">
        <SyntaxHighlighter
          language="json"
          style={oneDark}
          customStyle={{
            margin: 0,
            padding: '1rem',
            background: 'var(--surface)',
            fontSize: '0.8125rem',
            lineHeight: '1.5',
            maxHeight: '500px',
            overflow: 'auto',
          }}
          showLineNumbers
          lineNumberStyle={{
            minWidth: '2.5em',
            paddingRight: '1em',
            color: 'var(--muted)',
            userSelect: 'none',
          }}
        >
          {jsonString}
        </SyntaxHighlighter>
      </div>
    </div>
  );
}
</file>

<file path="components/MemoInput.tsx">
'use client';

interface MemoInputProps {
  value: string;
  onChange: (value: string) => void;
  disabled?: boolean;
}

export function MemoInput({ value, onChange, disabled }: MemoInputProps) {
  return (
    <div className="w-full">
      <label 
        htmlFor="memo-input" 
        className="block text-sm font-medium text-[var(--muted)] mb-2"
      >
        Investment Memo
      </label>
      <textarea
        id="memo-input"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        disabled={disabled}
        placeholder="Paste your investment memo here...

Expected format includes:
• Overview Table (project metadata)
• 'Tell it to me straight' section
• Strategic Fit analysis
• Highlights and key findings
• 'What You Would Have To Believe' assumptions
• Six-T Risk Analysis (Team, TAM, Technology, Traction, Terms, Trends)
• 'Should We Do It' and 'Can We Do It' assessments
• Chapter analyses (Team, Opportunity, Path to Success, Operations)"
        className="w-full h-[400px] px-4 py-3 bg-[var(--surface)] border border-[var(--border)] 
                   rounded-lg text-[var(--foreground)] placeholder-[var(--muted)]
                   focus:outline-none focus:ring-2 focus:ring-[var(--accent)] focus:border-transparent
                   resize-none font-mono text-sm leading-relaxed
                   disabled:opacity-50 disabled:cursor-not-allowed
                   transition-all duration-200"
        spellCheck={false}
      />
      <div className="mt-2 flex justify-between text-xs text-[var(--muted)]">
        <span>
          {value.length.toLocaleString()} characters
        </span>
        <span>
          Minimum 100 characters required
        </span>
      </div>
    </div>
  );
}
</file>

<file path="lib/openrouter.ts">
import { ExtractionResult, validateExtractionResult } from './schema';
import { EXTRACTION_SYSTEM_PROMPT, SIMPLIFIED_EXTRACTION_PROMPT, createUserPrompt } from './prompts';

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
const MODEL = 'google/gemini-2.5-pro-preview';

interface OpenRouterMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

interface OpenRouterResponse {
  id: string;
  choices: {
    message: {
      content: string;
    };
    finish_reason: string;
  }[];
  error?: {
    message: string;
    code: string;
  };
}

export interface ExtractionResponse {
  success: boolean;
  data?: ExtractionResult;
  error?: string;
  retried?: boolean;
}

/**
 * Extracts JSON from a response that might contain markdown code blocks
 */
function extractJsonFromResponse(content: string): string {
  // Try to extract JSON from markdown code blocks
  const jsonBlockMatch = content.match(/```(?:json)?\s*([\s\S]*?)```/);
  if (jsonBlockMatch) {
    return jsonBlockMatch[1].trim();
  }
  
  // Try to find raw JSON object
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (jsonMatch) {
    return jsonMatch[0];
  }
  
  return content.trim();
}

/**
 * Calls OpenRouter API with the given messages
 */
async function callOpenRouter(
  messages: OpenRouterMessage[],
  apiKey: string
): Promise<{ content: string; error?: string }> {
  try {
    const response = await fetch(OPENROUTER_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`,
        'HTTP-Referer': 'https://olsenator.vercel.app',
        'X-Title': 'The Olsenator',
      },
      body: JSON.stringify({
        model: MODEL,
        messages,
        temperature: 0.1, // Low temperature for consistent extraction
        max_tokens: 8192,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('OpenRouter API error:', response.status, errorText);
      return {
        content: '',
        error: `API request failed with status ${response.status}: ${errorText}`,
      };
    }

    const data: OpenRouterResponse = await response.json();

    if (data.error) {
      return {
        content: '',
        error: `OpenRouter error: ${data.error.message}`,
      };
    }

    if (!data.choices || data.choices.length === 0) {
      return {
        content: '',
        error: 'No response generated by the model',
      };
    }

    return {
      content: data.choices[0].message.content,
    };
  } catch (error) {
    console.error('OpenRouter request failed:', error);
    return {
      content: '',
      error: error instanceof Error ? error.message : 'Unknown error occurred',
    };
  }
}

/**
 * Attempts to parse and validate the extraction result
 */
function parseExtractionResult(content: string): { data?: ExtractionResult; error?: string } {
  try {
    const jsonContent = extractJsonFromResponse(content);
    const parsed = JSON.parse(jsonContent);
    
    if (!validateExtractionResult(parsed)) {
      return { error: 'Response does not match expected schema structure' };
    }
    
    return { data: parsed as ExtractionResult };
  } catch (error) {
    console.error('JSON parse error:', error);
    return { 
      error: error instanceof Error ? `Invalid JSON: ${error.message}` : 'Failed to parse JSON' 
    };
  }
}

/**
 * Main extraction function - extracts structured data from an investment memo
 * 
 * @param memoContent - The raw investment memo text
 * @param apiKey - OpenRouter API key
 * @returns ExtractionResponse with success status and data or error
 */
export async function extractMemoData(
  memoContent: string,
  apiKey: string
): Promise<ExtractionResponse> {
  if (!memoContent.trim()) {
    return {
      success: false,
      error: 'Memo content cannot be empty',
    };
  }

  if (!apiKey) {
    return {
      success: false,
      error: 'OpenRouter API key is not configured',
    };
  }

  // First attempt with full prompt
  const messages: OpenRouterMessage[] = [
    { role: 'system', content: EXTRACTION_SYSTEM_PROMPT },
    { role: 'user', content: createUserPrompt(memoContent) },
  ];

  console.log('Attempting extraction with full prompt...');
  const firstResponse = await callOpenRouter(messages, apiKey);

  if (firstResponse.error) {
    return {
      success: false,
      error: firstResponse.error,
    };
  }

  // Try to parse first response
  const firstParse = parseExtractionResult(firstResponse.content);
  if (firstParse.data) {
    return {
      success: true,
      data: firstParse.data,
    };
  }

  // Retry with simplified prompt
  console.log('First attempt failed, retrying with simplified prompt...');
  console.log('First attempt error:', firstParse.error);

  const retryMessages: OpenRouterMessage[] = [
    { role: 'system', content: SIMPLIFIED_EXTRACTION_PROMPT },
    { role: 'user', content: createUserPrompt(memoContent) },
  ];

  const retryResponse = await callOpenRouter(retryMessages, apiKey);

  if (retryResponse.error) {
    return {
      success: false,
      error: `Retry failed: ${retryResponse.error}`,
      retried: true,
    };
  }

  const retryParse = parseExtractionResult(retryResponse.content);
  if (retryParse.data) {
    return {
      success: true,
      data: retryParse.data,
      retried: true,
    };
  }

  return {
    success: false,
    error: `Failed to extract valid JSON after retry. Last error: ${retryParse.error}`,
    retried: true,
  };
}
</file>

<file path="lib/prompts.ts">
import { EXTRACTION_SCHEMA_JSON } from './schema';

/**
 * System prompt for Gemini 2.5 Pro to extract structured data from investment memos
 */
export const EXTRACTION_SYSTEM_PROMPT = `You are a specialized structured data extractor for investment memos. Your role is to parse investment memo documents and extract key information into a precise JSON format.

## Your Task
Analyze the provided investment memo and extract all relevant information into the JSON schema specified below. You must:

1. **Output valid JSON only** - No markdown, no explanations, just the JSON object
2. **Extract and summarize** - Condense verbose sections into concise summaries rather than copying verbatim
3. **Infer ratings and confidence** - When ratings (red/yellow/green) or confidence levels aren't explicitly stated, infer them from contextual language:
   - Strong positive language → green / High confidence
   - Mixed or cautionary language → yellow / Medium confidence  
   - Negative or warning language → red / Low confidence
4. **Handle missing sections gracefully** - Use null for missing values, empty arrays for missing lists. NEVER hallucinate or fabricate information
5. **Self-report confidence** - Set the top-level "confidence" field (0-100) based on:
   - How well the input memo matched expected structure
   - How complete the information was
   - How confident you are in your extractions

## Expected Memo Structure
Investment memos typically contain:
- Overview Table (project metadata)
- "Tell it to me straight" section (blunt assessment)
- Strategic Fit analysis
- Highlights (key findings with metrics)
- "What You Would Have To Believe" (critical assumptions)
- Hypotheses/Next Steps
- Six-T Risk Analysis (Team, TAM, Technology, Traction, Terms, Trends)
- "Should We Do It" and "Can We Do It" assessments
- Detailed chapters: Team, Opportunity Validation, Path to Success, Operations

## Output Schema
Your response must be a valid JSON object matching this exact structure:

${EXTRACTION_SCHEMA_JSON}

## Field Guidelines

### metadata
- projectName: The name of the project/initiative being evaluated
- stage: Investment stage (e.g., "Seed", "Series A", "Proof of Concept", "Pilot")
- industry: Primary industry or sector
- location: Geographic location if mentioned, null otherwise
- decision: Overall recommendation - must be exactly "Proceed", "Do Not Proceed", or "Conditional"
- recommendation: One-sentence summary of the recommendation

### executiveSummary
- verdict: The core "tell it to me straight" assessment in 1-2 sentences
- coreReasoning: Array of 3-5 key points supporting the verdict

### strategicFit
- assessment: Summary of how well the project aligns with strategic goals
- confidenceLevel: "High", "Medium", or "Low"

### highlights
Extract 4-8 key metrics or findings. For each:
- metric: What is being measured (e.g., "Market Size", "IRR", "Customer Acquisition Cost")
- value: The specific number or result (e.g., "$50B", "127%", "18 months")
- context: Brief explanation of significance

### criticalAssumptions
Extract assumptions from "What You Would Have To Believe" section:
- assumption: The belief or assumption stated
- status: "validated" (evidence supports it), "pending" (untested), or "at-risk" (evidence contradicts)

### sixTRisks
For each of the six T's:
- rating: "red" (high risk), "yellow" (moderate risk), or "green" (low risk)
- summary: One sentence explaining the rating

### shouldWeDoIt / canWeDoIt
- verdict: One-sentence answer to the question
- confidenceLevel: "High", "Medium", or "Low"
- supportingFactors: Array of 3-5 bullet points

### nextSteps
Extract recommended actions:
- action: What should be done
- rationale: Why this action matters
- successGate: How to know if it succeeded

### chapters
For each chapter, extract:
- Summary assessments and key findings
- dataPoints: 2-3 specific extractable data points suitable for visualization

Remember: Output ONLY the JSON object. No other text.`;

/**
 * Simplified retry prompt for when initial extraction fails
 */
export const SIMPLIFIED_EXTRACTION_PROMPT = `Extract key information from this investment memo into JSON format.

Output a JSON object with these fields:
- confidence (number 0-100)
- metadata (projectName, stage, industry, location, decision, recommendation)
- executiveSummary (verdict, coreReasoning array)
- strategicFit (assessment, confidenceLevel)
- highlights (array of metric/value/context objects)
- criticalAssumptions (array of assumption/status objects)
- sixTRisks (team/tam/technology/traction/terms/trends, each with rating and summary)
- shouldWeDoIt (verdict, confidenceLevel, supportingFactors)
- canWeDoIt (verdict, confidenceLevel, supportingFactors)
- nextSteps (array of action/rationale/successGate objects)
- chapters (team/opportunityValidation/pathToSuccess/operations with relevant fields)

Use null for missing values. Ratings are "red"/"yellow"/"green". Confidence levels are "High"/"Medium"/"Low".

Output ONLY valid JSON, no other text.`;

/**
 * Creates the user prompt with the memo content
 */
export function createUserPrompt(memoContent: string): string {
  return `Please extract structured data from the following investment memo:

---
${memoContent}
---

Remember: Output ONLY the JSON object matching the schema. No explanations or markdown.`;
}
</file>

<file path="lib/schema.ts">
/**
 * Extraction Schema for The Olsenator
 * 
 * This schema defines the structure of JSON data extracted from investment memos.
 * It is designed to be visualization-ready for Stage 2's rendering engine.
 */

export type RiskRating = "red" | "yellow" | "green";
export type ConfidenceLevel = "High" | "Medium" | "Low";
export type Decision = "Proceed" | "Do Not Proceed" | "Conditional";
export type AssumptionStatus = "validated" | "pending" | "at-risk";

export interface RiskAssessment {
  rating: RiskRating;
  summary: string;
}

export interface Highlight {
  metric: string;
  value: string;
  context: string;
}

export interface CriticalAssumption {
  assumption: string;
  status: AssumptionStatus;
}

export interface NextStep {
  action: string;
  rationale: string;
  successGate: string;
}

export interface ProjectMetadata {
  projectName: string;
  stage: string;
  industry: string;
  location: string | null;
  decision: Decision;
  recommendation: string;
}

export interface ExecutiveSummary {
  verdict: string;
  coreReasoning: string[];
}

export interface StrategicFit {
  assessment: string;
  confidenceLevel: ConfidenceLevel;
}

export interface SixTRisks {
  team: RiskAssessment;
  tam: RiskAssessment;
  technology: RiskAssessment;
  traction: RiskAssessment;
  terms: RiskAssessment;
  trends: RiskAssessment;
}

export interface Verdict {
  verdict: string;
  confidenceLevel: ConfidenceLevel;
  supportingFactors: string[];
}

export interface TeamChapter {
  capabilityAssessment: string;
  identifiedGaps: string[];
  dataPoints: string[];
}

export interface OpportunityValidationChapter {
  problemStatement: string;
  marketSize: string;
  competitivePositioning: string;
  dataPoints: string[];
}

export interface PathToSuccessChapter {
  productRequirements: string;
  goToMarket: string;
  revenueModel: string;
  dataPoints: string[];
}

export interface OperationsChapter {
  irr: string | null;
  paybackPeriod: string | null;
  margins: string | null;
  operationalRisks: string[];
  dataPoints: string[];
}

export interface Chapters {
  team: TeamChapter;
  opportunityValidation: OpportunityValidationChapter;
  pathToSuccess: PathToSuccessChapter;
  operations: OperationsChapter;
}

export interface ExtractionResult {
  /** Self-reported confidence score (0-100) based on input quality */
  confidence: number;
  
  /** Project metadata from the Overview Table */
  metadata: ProjectMetadata;
  
  /** Executive summary from "Tell it to me straight" section */
  executiveSummary: ExecutiveSummary;
  
  /** Strategic fit assessment with confidence level */
  strategicFit: StrategicFit;
  
  /** Key highlights with metrics and context */
  highlights: Highlight[];
  
  /** Critical assumptions with validation status */
  criticalAssumptions: CriticalAssumption[];
  
  /** Six-T Risk Analysis ratings */
  sixTRisks: SixTRisks;
  
  /** "Should We Do It" verdict and supporting factors */
  shouldWeDoIt: Verdict;
  
  /** "Can We Do It" verdict and supporting factors */
  canWeDoIt: Verdict;
  
  /** Recommended next steps with actions and success gates */
  nextSteps: NextStep[];
  
  /** Detailed chapter-level extractions */
  chapters: Chapters;
}

/**
 * JSON Schema representation for embedding in prompts
 * This is used to instruct the LLM on exact output structure
 */
export const EXTRACTION_SCHEMA_JSON = `{
  "confidence": number (0-100),
  "metadata": {
    "projectName": string,
    "stage": string,
    "industry": string,
    "location": string | null,
    "decision": "Proceed" | "Do Not Proceed" | "Conditional",
    "recommendation": string
  },
  "executiveSummary": {
    "verdict": string,
    "coreReasoning": string[]
  },
  "strategicFit": {
    "assessment": string,
    "confidenceLevel": "High" | "Medium" | "Low"
  },
  "highlights": [
    {
      "metric": string,
      "value": string,
      "context": string
    }
  ],
  "criticalAssumptions": [
    {
      "assumption": string,
      "status": "validated" | "pending" | "at-risk"
    }
  ],
  "sixTRisks": {
    "team": { "rating": "red" | "yellow" | "green", "summary": string },
    "tam": { "rating": "red" | "yellow" | "green", "summary": string },
    "technology": { "rating": "red" | "yellow" | "green", "summary": string },
    "traction": { "rating": "red" | "yellow" | "green", "summary": string },
    "terms": { "rating": "red" | "yellow" | "green", "summary": string },
    "trends": { "rating": "red" | "yellow" | "green", "summary": string }
  },
  "shouldWeDoIt": {
    "verdict": string,
    "confidenceLevel": "High" | "Medium" | "Low",
    "supportingFactors": string[]
  },
  "canWeDoIt": {
    "verdict": string,
    "confidenceLevel": "High" | "Medium" | "Low",
    "supportingFactors": string[]
  },
  "nextSteps": [
    {
      "action": string,
      "rationale": string,
      "successGate": string
    }
  ],
  "chapters": {
    "team": {
      "capabilityAssessment": string,
      "identifiedGaps": string[],
      "dataPoints": string[]
    },
    "opportunityValidation": {
      "problemStatement": string,
      "marketSize": string,
      "competitivePositioning": string,
      "dataPoints": string[]
    },
    "pathToSuccess": {
      "productRequirements": string,
      "goToMarket": string,
      "revenueModel": string,
      "dataPoints": string[]
    },
    "operations": {
      "irr": string | null,
      "paybackPeriod": string | null,
      "margins": string | null,
      "operationalRisks": string[],
      "dataPoints": string[]
    }
  }
}`;

/**
 * Validates that an object matches the ExtractionResult structure
 * Returns true if valid, false otherwise
 */
export function validateExtractionResult(data: unknown): data is ExtractionResult {
  if (!data || typeof data !== 'object') return false;
  
  const result = data as Record<string, unknown>;
  
  // Check top-level required fields
  if (typeof result.confidence !== 'number') return false;
  if (!result.metadata || typeof result.metadata !== 'object') return false;
  if (!result.executiveSummary || typeof result.executiveSummary !== 'object') return false;
  if (!result.strategicFit || typeof result.strategicFit !== 'object') return false;
  if (!Array.isArray(result.highlights)) return false;
  if (!Array.isArray(result.criticalAssumptions)) return false;
  if (!result.sixTRisks || typeof result.sixTRisks !== 'object') return false;
  if (!result.shouldWeDoIt || typeof result.shouldWeDoIt !== 'object') return false;
  if (!result.canWeDoIt || typeof result.canWeDoIt !== 'object') return false;
  if (!Array.isArray(result.nextSteps)) return false;
  if (!result.chapters || typeof result.chapters !== 'object') return false;
  
  // Validate Six-T structure
  const sixT = result.sixTRisks as Record<string, unknown>;
  const requiredRisks = ['team', 'tam', 'technology', 'traction', 'terms', 'trends'];
  for (const risk of requiredRisks) {
    if (!sixT[risk] || typeof sixT[risk] !== 'object') return false;
    const riskObj = sixT[risk] as Record<string, unknown>;
    if (!['red', 'yellow', 'green'].includes(riskObj.rating as string)) return false;
    if (typeof riskObj.summary !== 'string') return false;
  }
  
  return true;
}
</file>

<file path="next.config.mjs">
/** @type {import('next').NextConfig} */
const nextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="package.json">
{
  "name": "olsenator",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "^14.2.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-syntax-highlighter": "^15.5.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@types/react-syntax-highlighter": "^15.5.11",
    "autoprefixer": "^10.4.0",
    "eslint": "^8.0.0",
    "eslint-config-next": "^14.2.0",
    "postcss": "^8.4.0",
    "tailwindcss": "^3.4.0",
    "typescript": "^5.0.0"
  }
}
</file>

<file path="postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

export default config;
</file>

<file path="README.md">
# The Olsenator — Extraction Engine

Transform investment memos into structured JSON data for visualization.

## Overview

The Olsenator is an infographic generator that transforms structured investment memos into visually rich, branded HTML infographics. This repository contains **Stage 1: The Extraction Engine** — a Next.js application that parses investment memos and extracts structured data into a fixed JSON schema.

**Stage 2** (future build) will be the Rendering Engine that consumes this JSON and produces deterministic, templated HTML infographics.

## Features

- **AI-Powered Extraction**: Uses Gemini 2.5 Pro via OpenRouter to intelligently parse investment memos
- **Comprehensive Schema**: Captures all memo elements including metadata, Six-T risks, highlights, and chapter analyses
- **Robust Error Handling**: Automatic retry with simplified prompts when extraction fails
- **Minimal UI**: Clean, dark interface for pasting memos and viewing extracted JSON
- **Copy to Clipboard**: Easy export of extracted JSON for downstream use

## Getting Started

### Prerequisites

- Node.js 18+ 
- An [OpenRouter](https://openrouter.ai/) API key

### Installation

1. Clone the repository:
   ```bash
   git clone <repository-url>
   cd olsenator
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Create a `.env.local` file with your OpenRouter API key:
   ```
   OPENROUTER_API_KEY=your_openrouter_api_key_here
   ```

4. Start the development server:
   ```bash
   npm run dev
   ```

5. Open [http://localhost:3000](http://localhost:3000) in your browser.

## Usage

1. Paste your investment memo text into the input area
2. Click "Extract Data"
3. Wait for the AI to process (typically 10-30 seconds)
4. View the structured JSON output
5. Click "Copy JSON" to export the data

## JSON Schema

The extraction produces a comprehensive JSON object with the following structure:

```typescript
{
  confidence: number;           // 0-100 self-reported extraction confidence
  metadata: {
    projectName, stage, industry, location, decision, recommendation
  };
  executiveSummary: {
    verdict, coreReasoning[]
  };
  strategicFit: {
    assessment, confidenceLevel
  };
  highlights: Array<{ metric, value, context }>;
  criticalAssumptions: Array<{ assumption, status }>;
  sixTRisks: {
    team, tam, technology, traction, terms, trends
    // Each with { rating: "red"|"yellow"|"green", summary }
  };
  shouldWeDoIt: { verdict, confidenceLevel, supportingFactors[] };
  canWeDoIt: { verdict, confidenceLevel, supportingFactors[] };
  nextSteps: Array<{ action, rationale, successGate }>;
  chapters: {
    team: { capabilityAssessment, identifiedGaps[], dataPoints[] },
    opportunityValidation: { problemStatement, marketSize, competitivePositioning, dataPoints[] },
    pathToSuccess: { productRequirements, goToMarket, revenueModel, dataPoints[] },
    operations: { irr, paybackPeriod, margins, operationalRisks[], dataPoints[] }
  };
}
```

## Tech Stack

- **Framework**: Next.js 14 with App Router
- **Styling**: Tailwind CSS
- **LLM**: Gemini 2.5 Pro via OpenRouter
- **Syntax Highlighting**: react-syntax-highlighter

## Deployment

This application is configured for deployment on Vercel:

```bash
npm run build
```

Make sure to set `OPENROUTER_API_KEY` in your Vercel project environment variables.

## Project Structure

```
├── app/
│   ├── layout.tsx        # Root layout
│   ├── page.tsx          # Main extraction UI
│   ├── globals.css       # Tailwind imports and CSS variables
│   └── api/extract/
│       └── route.ts      # OpenRouter API integration
├── lib/
│   ├── schema.ts         # TypeScript interfaces and validation
│   ├── prompts.ts        # Gemini system prompts
│   └── openrouter.ts     # OpenRouter client wrapper
├── components/
│   ├── MemoInput.tsx     # Text input component
│   ├── JsonOutput.tsx    # Syntax-highlighted JSON display
│   └── CopyButton.tsx    # Copy to clipboard button
└── package.json
```

## License

Built for Innovera.ai
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";

const config: Config = {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      fontFamily: {
        sans: ["var(--font-geist-sans)"],
        mono: ["var(--font-geist-mono)"],
      },
    },
  },
  plugins: [],
};

export default config;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

</files>
